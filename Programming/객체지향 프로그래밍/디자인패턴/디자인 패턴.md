# 디자인 패턴

객체 지향 설계는 소프트웨어로 해결하고자 하는 문제를 다루면서, 동시에 재설계 없이 또는 재설계를 최소화하면서 요구 사항의 변화를 수용할 수 있도록 만들어 줍니다. 객체 지향 설계를 하다 보면, 이전과 비슷한 상황에서 사용했던 설계를 재사용하는 경우가 종종 발생합니다. 

이런 설계는 특정 상황에 맞는 해결책을 빠르게 찾을 수 있도록 도와주는데, 이렇게 반복적으로 사용되는 설계는 클래스, 객체의 구성, 객체 간 메시지 흐름에서 일정 패턴을 갖습니다.
이런 패턴을 잘 습득하면 다음과 같은 이득을 얻을 수 있게 됩니다.

- 상황에 맞는 올바른 설계를 더 빠르게 적용할 수 있습니다.
- 각 패턴의 장단점을 통해서 설계를 선택하는데 도움을 얻을 수 있습니다.
- 설계 패턴에 이름을 붙임으로써 시스템의 문서화, 이해, 유지 보수에 도움을 얻을 수 있습니다.

이 분야에 자주 사용되는 패턴들을 모아서 집대성한 다양한 책이 존재하는데, 그 중에서도 가장 유명한 GoF의 디자인 패턴은 많은 프로그래머들에게 도움을 주었습니다. 이 책은 객체지향 프로그래밍에서 발견된 여러 패턴들을 모아놓은 책으로서, 소프트웨어 개발에서 자주 만나게 되는 일반적인 문제를 해결해 주는 설계를 제시하고 있습니다. GoF의 디자인 패턴은 객체의 생성, 기능의 확장, 기능의 변경, 구조 등과 관련된 약 20여개에 이르는 패턴을 정리하고 있습니다.

이번 포스팅에서는 GoF의 패턴 중에서도 영역에 상관없이 자주 사용되는 패턴에 대해서 소개하겠습니다.

- 전략 패턴 / 템플릿 메서드 패턴 / 상태 패턴
- 데코레이터 패턴 / 프록시 패턴 / 어댑터 패턴
- 옵저버 패턴 / 미디에이터 패턴 / 파사드 패턴
- 추상 팩토리 패턴 / 컴포지트 패턴

그리고 GoF에는 속해 있지 않는 널(Null) 객체 패턴을 추가하였습니다. 이들 패턴은 개발과정에서 자주 사용하는 패터닝ㄴ 만큼, 익혀 두면 많은 도움을 얻을 것 입니다.

## 전략 패턴

한 과일 매장은 상황에 따라 다른 가격 할인 정책을 적용하고 있습니다. 매장을 열자마자 들어온 첫 손님을 위한 `첫 손님 할인`정책과 저녁 시간대에 신선도가 떨어진 과일에 대한 `덜 신선한 과일 할인`정책이 있다면, 아래 코드처럼 계산하는 모듈에 이런 가격 할인 정책을 적용하기 위한 if-else 블록이 포함될 것입니다.

```java
public class Calculator {

    public int calculate(boolean firstGuest, List<Item> items) {
        int sum = 0;
        for(Item item: items) {
            if(firstGuest) 
                sum += (int) (item.getPrice() * 0.9); // 첫 손님 10% 할인
            else if(!item.isFresh())
                sum += (int) (item.getPrice() * 0.8); // 덜 신선한 것 20% 할인
            else
                sum += item.getPrice();
        }
        return sum;
    }
}
```

위 코드는 비교적 간단하지만 다음의 문제를 포함하고 있습니다.

- 서로 다른 계산 정책들이 한 코드에 섞여 있어, 정책이 추가될수록 코드 분석을 어렵게 만듭니다.

- 가격 정책이 추가될 때마다 calculate 메서드를 수정하는 것이 점점 어려워집니다. 예를 들어 마지막 손님 50% 할인과 같은 새로운 가격 정책이 추가될 경우, calculate 메서드에 마지막 손님을 구분하기 위한 lastGuest 파라미터가 추가되고, if 블록이 하나 더 추가되어야 합니다.

이런 문제를 해결하기 위한 방법 중의 하나는 아래 그림처럼 가격 할인 정책을 별도 객체로 분리하는 것입니다.

![Untitled Diagram](https://user-images.githubusercontent.com/22395934/79305980-4d94a880-7f2f-11ea-8b28-aa4d32cfe87e.png)

위 그림에서 DiscountStrategy 인터페이스는 상품의 할인 금액 계산을 추상화하였고, 각 콘크리트 클래스는 상황에 맞는 할인 계산 알고리즘을 제공합니다. Calculator 클래스는 가격 합산 게산의 책임을 집니다. 여기서 가격 할인 알고리즘을 추상화하고 있는 DiscountStrategy을 전략이라고 부르고 가격 계산 기능 자체의 책임을 갖고 있는 Caculator를 콘텍스트라고 부르는데, 이렇게 특정 콘텍스트에서 알고리즘을 별도로 분리하는 설계 방법이 `전략 패턴`입니다.

전략 패턴에서 콘텍스트는 사용할 전략을 직접 선택하지 않습니다. 대신 콘텍스트의 클라이언트가 콘텍스트에 사용햘 전략을 전달 해줍니다. 즉 DI(의존성 주입)를 이용해서 콘텍스트에 전략을 전달해 줍니다. 그리고 전략이 어떤 메서드를 제공할 지의 여부는 콘텍스트가 전략을 어떤 식으로 사용하느냐에 따라 달라집니다.

앞서 위에 그림에서 보여주는 금액 할인 정책을 DiscountStrategy로 분리한 경우, 아래 코드처럼 Calculator를 구현할 수 있을 것입니다.

```java
public class Caluclator {

    private DiscountStrategy discountStrategy;

    public Calculator(DiscountStrategy discountStrategy) {
        this.discountStrategy = discountStrategy;
    }

    public int calculator(List<Item> items) {
        int sum = 0;
        for(Item item: items) {
            sum += discoutStrategy.discountPrice(item);
        }
    }
    return sum;
}
```

코드를 살펴보면 Calculator 클래스는 생성자를 통해서 사용할 전략 객체를 전달받고, calculate() 메서드에 각 Item의 가격을 계산할 때 전략 객체를 사용하고 있습니다. 위 코드에서 Calculator는 각 Item 별로 할인 정책을 적용하고 있으므로 DiscountStrategy 인터페이스는 아래 코드처럼 정의될 것입니다.

```java
public interface DiscountStrategy {
    public int getDiscountPrice();
}
```

만약 각 아이템 별로 할인 정책이 있고, 전체 금액에 대한 할인 정책이 별도로 필요하다면, DiscountStrategy의 인터페이스에 전체 금액 할인을 위한 메서드가 추가될 것입니다.

```java
public interface DiscountStrategy {
    public int getDiscountPrice(Item item);
    public int getDiscountPrice(int totalPrice);
}
```

또는, 전체 금액 할인 정책을 위한 전략을 별도 인터페이스로 분리할 수도 있을 것입니다.

```java
public interface ItemDiscountStrategy {
    int getDiscountPrice(Item item);
}

public interface TotalPriceDiscountStrategy {
    int getDiscountPrice(int totalPrice);
}
```
전략 객체는 콘텍스트를 사용하는 클라이언트에서 직접 생성합니다. 예를 들어, 첫 번째 손님에 대해 할인을 해주는 FirstGuestDiscountStrategy 구현 클래스를 아래 코드와 같이 구현했다고 합시다.

```java
public class FirstGuestDiscountStrategy implements DiscountStrategy {

    @Override
    public int getDiscountPrice(Item item) {
        return (int) (item.getPrice() * 0.9);
    }
}
```

첫 번째 손님이 들어와서 계산을 하면, 계산기에서 첫 번째 손님 할인 적용 버튼을 누른 뒤에 계산 버튼을 누를 것입니다. 이를 처리하는 코드는 다음과 같은 방식으로 작성될 것입니다.

```java
private DiscoutStrategy strategy;

public void onFirstGuestButtonClick() {
    // 첫 손님 할인 버튼 투를 때 생성 됩니다.
    strategy = new FirstGuestDiscountStrategy();
}

public void onCalculationButtonClick() {
    // 계산 버튼 누를 때 실행됨
    Calculator cal = new Calculator(strategy);
    int price = cal.calculate(items);
    ...
}
```

위 코드를 보면 Calculator를 사용하는 코드에서 FirstGuestDiscountStrategy 클래스의 객체를 생성하는 것을 알 수 있습니다. 이는 콘텍스트를 사용하는 클라이언트가 아래 그림처럼 전략의 상세 구현에 대한 의존이 발생한다는 것을 뜻합니다.

![Untitled Diagram (1)](https://user-images.githubusercontent.com/22395934/79309574-7ae45500-7f35-11ea-93d8-b677895acfbb.png)

콘텍스트의 클라이언트가 전략 인터페이스가 아닌 상세 구현을 안다는 것이 문제처럼 보일 수 있으나, 이 경우에는 전략의 콘크리트 클래스와 클라이언트의 코드가 쌍을 이루기 때문에 유지 보수 문제가 발생할 가능성이 줄어듭니다.

예를 들어, 덜 신선한 과일 할인 정책을 추가하려면 클라이언트에 덜 신선한 과일 할인 정책 적용 버튼을 처리하는 코드가 생기고 이 코드에서 NonFreshDiscountStrategy 객체를 생성해 주게 됩니다. 또한 기능이 제거될 때에도 함께 제거됩니다. 따라서 클라이언트의 버튼 처리 코드에서 전략 객체를 직접 생성하는 것은 오히려 코드 이해를 높이고 코드 응집을 높여주는 효과를 갖습니다.


전략 패턴을 적용할 때 얻을 수 있는 이점은 콘텍스트 코드의 변경 없이 새로운 전략을 추가할 수 있다는 점입니다. 앞에서 본 예제에서 마지막 손님 대폭 할인 정책을 추가하는 경우, 계산을 제공하는 Calculator 클래스의 코드는 변경되지 않습니다. 단지 새로운 할인 정책을 구현한 LastGuestDiscountStrategy 클래스를 추가하고, 마지막 손님 대폭 할인 버튼을 클릭을 처리하는 코드에서 LastGuestDiscountStrategy의 객체를 생성해 주기만 하면 됩니다.


```java
private DiscountStrategy strategy;

public void onLastGuestButtonClick() {
    // 마지막 손님 대폭 할인 버튼 누를 때 생성됨
    strategy = new LastGuestDiscountStrategy();

}

public void onCalculationButtonClick() {
    // 계산 버튼 누를 때 실행 됩니다.
    Calculator cal = new Calculator(strategy);
    int price = cal.calculate(items);
    ...
}
```

전략 패턴을 적용함으로써 Calculator 클래스는 할인 정책 확장에는 열려 있고 변경에는 닫혀 있게 됩니다. 즉, 개방 폐쇄 원칙을 따르는 구조를 갖게 됩니다.

일반적으로 if-else로 구성된 코드 블록이 비슷한 기능을 수행하는 경우에 전략 패턴을 적용함으로써 코드를 확장 가능하도록 변경할 수 있습니다. 위에서 살펴본 if-else 블록에 따라 전략 패턴을 적용함으로써 새로운 할인 정책을 보다 쉽게 추가할수 있도록 만들어보았습니다.



## 템플릿 메서드 패턴
프로그램을 구현하다 보면, 완전한 동일한 절차를 가진 코드를 작성하게 될 때가 있습니다. 심지어 이 코드들은 절차 중 일부 과정의 구현만 다를 뿐 나머지 구현은 똑같을 때도 있습니다. 예를 들어, DB 데이터와 LDAP를 이용해서 인증을 처리하는 클래스는 사용자 정보를 가져오는 부분의 구현만 다를 뿐 인증을 처리하는 과정은 완전히 동일할 수 있습니다.

DB나 LDAP이 아닌 중간에 인증 서버를 두는 경우라도 두 클래스와 거의 유사한 코드를 갖게 될 것입니다. 이렇게 실행 과정/단계는 동일한데 각 단계 중 일부의 구현이 다른 경우에 사용할 수 있는 패턴이 `템플릿 메서드 `패턴 입니다. 템플릿 메서드 패턴은 다음과 같이 두 가지로 구성됩니다.

- 실행 과정을 구현한 상위 클래스
- 실행 과정의 일부 단계를 구현한 하위 클래스

상위 클래스는 실행 과정을 구현한 메서드를 제공합니다. 이 메서드는 기능을 구현하는데 필요한 각 단계를 정의하며 이 중 일부 단계는 추상 메서드를 호출하는 방식으로 구현됩니다. 이대 추상 메서드는 구현이 다른 단계에 해당합니다. 예를 들어, 템플릿 메서드 패턴을 적용하면 아래 코드와 같이 상위 클래스를 작성할 수 있습니다.


```java
public abstract class Authenticator {

    // 템플릿 메서드
    public Auth authenticate(String id, String pw) {
        if(!doAuthenticate(id, pw)) 
            throw createException();
        
        return createAuth(id);
    }

    protected abstract boolean doAuthenticate(String id, String pw);

    private RuntimeException createException() {
        throw new AuthException();
    }
    protected abstract Auth createAuth(String id);
}
```

authenticate() 메서드는 DbAuthenticator와 LdapAuthenticaotr에서 동일했던 실행 과정을 구현하고 있고, 두 클래스에서 차이가 나는 부분은 별도의 추상 메서드로 분리하였습니다.

예를 들어, id/pw를 이용해서 인증 여부를 확인하는 단계는 doAuthenticate() 추상 메서드로 분리하였고, Auth 객체를 생성하는 단계는 createAuth() 추상 메서드로 분리하였습니다. Authenticate() 메서드는 모든 하위 타입에 동일하게 적용되는 실행 과정을 제공하기 때문에, 이 메서드를 템플릿 메서드라고 부릅니다.

Authenticator 클래스를 상속받은 하위 클래스는 authenticate() 메서드에서 호출하는 다른 메서드만 알맞게 재정의 해주면 됩니다. 예를 들어 LdapAuthenticator 클래스는 아래 코드처럼 구현할 수 있습니다.

```java
public class LdapAuthenticator extends Authenticator {

    @Override
    protected boolean doAuthenticate(String id, String pw) {
        return ldapClient.authenticate(id, pw);
    }

    @Override
    protected Auth createAuth(String id) {
        LdapContext ctx = ldapClient.find(id);
        return new Auth(id, ctx.getAttribute("name"));
    }
}
```

LdapAuthenticator 클래스는 이제 전체 실행 과정 구현을 제공하지 않고 일부 과정의 구현만을 제공합니다. 전체 실행 과정은 상위 타입인 Authenticator의 authenticate() 메서드에서 제공하게 됩니다.

템플릿 메서드 패턴을 사용하게 되면, 동일한 실행과정의 구현을 제공하면서 동시에 하위 타입에서 일부 단계를 구현할 수 있도록 할 수 있습니다. 이는 각 타입에서 코드가 중복되는 것을 방지합니다.

템플릿 메서드 패턴을 적용하기 전에 DbAuthenticator와 LdapAuthenticator는 완전히 동일한 구조를 갖고 있었습니다. 차이점이라면 DB를 사용하느냐 LDAP를 사용하느냐 일뿐, 실행 과정 자체는 완전히 동일했습니다. 새로운 인증 방식이 추가되더라도 이 과정은 완전히 동일하기 때문에 거의 비슷한 코드가 중복될 것입니다. 중복된 코드가 출현한다는 것은 그만큼 유지 보수를 어렵게 만드는데, 템플릿 메서드 패턴을 사용함으로써 코드 중복 문제를 제거하면서 동시에 코드를 재사용 할 수 있게 합니다.

## 상위 클래스가 흐름 제어 주체
템플릿 메서드 패턴의 특징은 하위 클래스가 아닌 상위 클래스에서 흐름 제어를 한다는 것입니다. 일반적인 경우 하위 타입이 상위 타입의 기능을 재사용할지 여부를 결정하기 때문에, 흐름 제어를 하위 타입이 하게 됩니다. 예를 들어, 아래 코드에서 SuperCar 클래스의 turnOn() 메서드는 상위 클래스의 turnOn() 메서드를 재사용할지 여부를 자신이 결정합니다.

```java
public class SuperCar extends ZetEngine {

    @Override
    public void turnOn() {
        // 하위 클래스에서 흐름 제어
        if(notReady) 
            beep();
        else 
            super.turnOn();
    }
}
```

반면에 템플릿 메서드 패턴에서는 상위 타입의 템플릿 메서드가 모든 실행 흐름을 제어하고, 하위 타입의 메서드는 템플릿 메서드에 호출되는 구조를 갖게 됩니다.

템플릿 메서드인 authenticate() 메서드와 템플릿 메서드에서 호출하는 메서드인 doAuthenticate() / createAuth() 메서드의 접근 범위는 각가 public과 protected로 설정되어 있습니다. 템플릿 메서드의 경우 외부에서 제공하는 기능에 해당되기 때문에 public 범위를 가져야 하는 반면에 doAuthenticate() 메서드나 createAuth() 메서드는 템플릿 메서드에서만 호출되는 메서드로서 public일 필요가 없습니다. 이 두 메서드는 하위 타입에서 재정의할 수 있어야 하기 때문에 private이 아닌 protected 범위를 가져야 합니다.

이 예제에서는 템플릿 메서드에서 호출하는 메서드를 추상 메서드로 정의했는데, 기본 구현을 제공하고 하위 클래스에서 알맞게 재정의하도록 구현할 수도 있습니다. 이 경우 해당 메서드는 기능의 확장 지점으로 사용될 수 있습니다. 예를 들어, 안드로이드에서 비동기 처리를 위한 기능을 제공하는 AsyncTask 클래스의 코드를 보면, 아래처럼 doBackground() 추상 메서드와 빈 구현을 갖는 onPreExecute() 메서드를 제공하고 있습니다.

```java
public abstract class AsyncTask<Params, Progress, Result> {

    public AsyncTask() {
        mWorker = new WorkerRunnable<Params, Result>() {
            public Result call() throws Exception {
                mTaskInvoked.set(true);
                Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
                return postResult(doInBackground(mParams));
            }
        };
        ...
    }
    
    public final AsyncTask<Params, Progress, Result> executeOnExecutor(Executor exec, Params... params) {
        ...
        mStatus = Status.RUNNIN;
        onPreExecute();
        mWorker.mParams = params;
        exec.execute(mFuture);
        return this;
    }
    protected abstract Result doInBackground(Params... params);

    protected void onPreExecute() { // 하위 클래스의 확장 지점

    }
    ...// 기타 다른 코드
}
```

AsyncTask를 상속받아 구현하는 클래스는 doInBackground() 메서드는 반드시 구현해 주어야 하지만, onPreExecute() 메서드의 경우는 필요한 경우에만 구현해 주면 됩니다. 즉, onPreExecute() 메서드는 상위 클래스 입장에서는 제어 대상이 되는 확장 지점이 되며, 하위 클래스에 맞는 확장 기능을 구현할 위치가 됩니다.

> 훅 메서드란? 이렇게 상위 클래스에서 실행 시점이 제어되고, 기본 구현을 제공하면서, 하위 클래스에서 알맞게 확장할 수 있는 메서드를 훅(hook) 메서드라고 부릅니다. 


## 템플릿 메서드와 전략 패턴의 조합

템플릿 메서드와 전략 패턴을 함께 사용하면 상속이 아닌 조립의 방식으로 템플릿 메서드 패턴을 활용 할 수 있는데, 대표적인 예가 스프링 프레임워크의 Template으로 끝나는 클래스 들입니다. 이 클래스들은 템플릿 메서드를 실행할 때, 변경되는 부분을 실행할 객체를 파라미터를 통해서 전달받는 방식으로 구현되어 있습니다.

예를 들어, 트랜잭션 기능을 제공하는 TransactionTemplate 클래스의 execute() 메서드는 다음과 같이 구현되어 있습니다.

```java
public <T> T execute(TransactionCallback<T> action) throw TransactionException {
    // 일부 코드 생략
    TransactionStatus status = this.transactionManager.getTransaction(this);
    T result; 
    try {
        result = action.doInTransaction(status);
    } catch (RuntimeException ex) {
        rollbackOnException(status, ex);
        throw ex;
    }
    // 기타 다른 익셉션 처리 코드
    this.transactionManager.commit(status);
    return result;
}
```

execute() 메서드는 트랜잭션의 시작.커밋/롤백 등의 실행 흐름을 제공하는 템플릿 메서드인데, execute() 메서드는 앞서 살펴본 템플릿 메서드와 다음의 차이점이 있습니다.

- 앞서 템플릿 메서드가 하위 타입에서 재정의할 메서드를 호출하고 있다면
- TransactionTemplate의 execute() 메서드는 파라미터로 전달받은 action의 메서드를 호출하고 있습니다.

따라서 TransactionTemplate의 execute() 메서드를 사용하는 코드는 다음과 같이 execute() 메서드를 호출할 때 원하는 기능을 구현한 TransactionCallback 객체를 전달합니다.

```java
transactionTemplate.execute(new TransactionCallback<String>(){
    public String doInTransaction(TransactionStatus status) {
        // 트랜잭션 범위 안에서 실행될 코드 
    }
}); 

```

템플릿 메서드 패턴과 전략 패턴을 조합하게 되면, 상속에 기반을 둔 템플릿 메서드 구현과 비교해서 유연함을 갖습니다. 상속을 통한 재사용의 경우 앞에 포스팅에서 살펴봤듯이 클래스가 불필요하게 증가할 수 있고 런타임에 교체할 수 없는 단점이 있는 반면에 조립/위임을 사용하는 경우에 런타임에 템플릿 메소드에서 사용할 객체를 교체할 수 있는 장점을 갖게 됩니다.
하지만, 상속 방식의 경우 훅 메서드를 재정의 하는 방법으로 하위 클래스에서 쉽게 확장 기능을 제공할 수 있는 장점이 있는 반면에, 조립/위임 방식에서는 확장 기능을 제공하려면 구현이 다소 복잡해지는 단점이 있습니다.


## 팩토리 패턴

팩토리 패턴은 모든 객체 생성을 캡슐화하는 것을 의미합니다. 캡슐화는 단순히 외부에 어떤 객체를 생성하는지 숨기는 것입니다. 

팩토리 메서드 패턴은 객체를 생성하기 위한 인터페이스를 정의하는데, 어떤 클래스의 인스턴스를 만들지를 서브 클래스에 위임하여 결정하는 패턴을 의미합니다.

결론을 말하면 팩토리 패턴의 핵심은 `클래스의 인스턴스를 만드는 것을 서브 클래스에서 결정하도록 하는 것입니다.` 즉, new 키워드를 사용하는 부분을 서브 클래스에 위임함으로서 객체 생성을 캡슐화하고 구상 클래스에 대한 의존성이 줄어든다는 이점을 누릴 수 있습니다.

특히 구상 클래스에 대한 의존성이 줄어드는 것은 DI(의존 역전의 원칙)에 기인하는데, DI는 자바 진영에서 특히 Spring 프레임워크의 핵심 개념 중 하나이고, 오늘날에도 개발자들에게 많은 사랑을 받고있습니다. 또한 싱글톤 패턴과 더불어 가장 유명하고 널리 쓰이는 디자인 패턴 중 하나입니다.


## 팩토리 메소드 패턴
위에서 언급했듯이, 객체를 생성하기 위한 인터페이스를 정의하는데, 어떤 클래스의 인스턴스를 만들지는 서브 클래스에서 결정하도록 하는 것입니다. 팩토리 메서드 패턴은 팩토리 메서드는 객체를 생성해서 반환하는 것을 말합니다. 즉, 결과값이 객체인 것입니다.

여기서 얻을 수 있는 이점은 다음과 같습니다.

- 낮은 결합도
- 유지보수 용이성

만약 클래스의 기능 변경이 발생했을 때 이 클래스를 사용하는 클라이언트 코드에 얼마나 파급력을 미칠것인가는 곧 결합도를 의미합니다. 팩토리 메서드 패턴은 직접 사용하는 객체를 생성하지 않고 팩토리 메소드 클래스를 통해 객체를 대신 생성하고 그 객체를 반환받아 사용하기 때문에 효율적인 코드 제어를 할 수 있을 뿐더러 결합도를 낮추고 유지보수성이 향상되는 효과가 있습니다.

코드는 항상 실전이라고 생각합니다. 아무리 이론으로 공부해도 코드를 직접 짜보지 않으면 이해가 안가기 때문에 간단하게 자바를 이용해서 팩토리 메서드 패턴 예제 코드를 작성해보았습니다.

요즘 애니메이션 중에 포켓몬스터W를 보게 되었는데 옛날 추억이 생각나길래 포켓몬과 관련한 팩토리 메서드 패턴을 구현해보았습니다.

```java
Pocketmon pocketmon = null;

    switch (type) {

        case ("dragon"):
            pocketmon = new Mangnanyong("망나뇽");
            break;

        case ("ghost"):
            pocketmon = new Pantom("팬텀");
            break;

        case ("fighter"):
            pocketmon = new Rukario("루카리오");
            break;
        default:
            pocketmon = new Picachu("피카츄");
        }
```

위의 코드를 보면 type에 따라서 생성되는 포켓몬이 달라지게 됩니다. 하지만 위와 같이 코드를 작성하게 되면 변경이나 확장할 요소가 생길 시 매번 코드를 추가, 제거해주어야 한다는 문제가 발생합니다. 

위의 문제는 객체 인스턴스를 생성하는(new 키워드를 사용하는)부분을 별도의 인터페이스로 분리하면 해결 할 수 있습니다. 이렇게 생성자를 별도의 인터페이스로 분리하여 객체를 만들어내는 공장(factory)으로 이용하는 것이 팩토리 메소드 패턴입니다.

![Untitled Diagram (2)](https://user-images.githubusercontent.com/22395934/79581054-d9abf900-8104-11ea-95ea-7fb6283acc9a.png)

각 포켓몬 중 유명한 망나뇽, 팬텀, 루카리오는 Pocketmon 인터페이스를 구현하여 getName() 메소드를 구현하고 PocketmonFactory 인터페이를 구현하는 TypePocketmonFactory 클래스에서는 type 별로 포켓몬 인스턴스를 생성하도록 하는 createPocketmon 메소드를 구현하도록 합니다.

- Pocketmon 인터페이스

```java
public interface Pocketmon {
    public String getName();
}
 ```

- Pocketmon 인터페이스를 구현한 각각의 포켓몬들

```java
public class Mangnanyong implements Pocketmon {

    private String name;

    public Mangnanyong(String name) {
        this.name = name;
    }

    @Override
    public String getName() {
        return name;
    }
}

public class Pantom implements Pocketmon {

    private String name;

    public Pantom(String name) {
        this.name = name;
    }

    @Override
    public String getName() {
        return name;
    }

}

public class Rukario implements Pocketmon{

    private String name;

    public Rukario(String name) {
        this.name = name;
    }

    @Override
    public String getName() {
        return name;
    }
}
```


- PocketmonFactory

```java
public interface PocketmonFactory {
    public Pocketmon createPocketmon(String name);
}
```

- PocketmonFactory를 구현한 TypePocketmonFactory 콘크리트 클래스

```java
public class TypePocketmonFactory implements PocketmonFactory {

    @Override
    public Pocketmon createPocketmon(String type) {

        Pocketmon pocketmon = null;

        switch (type) {

            case ("dragon"):
                pocketmon = new Mangnanyong("망나뇽");
                break;

            case ("ghost"):
                pocketmon = new Pantom("팬텀");
                break;

            case ("fighter"):
                pocketmon = new Rukario("루카리오");
                break;
        }
        return pocketmon;
    }
}
```

- 실행 클래스

```java
// 팩토리 메서드 패턴 실행 예제 코드
public class FactoryPatternEx {

    public static void main(String[] args) {

        PocketmonFactory pocketmonFactory = new TypePocketmonFactory();

        Pocketmon pocketmon1 = pocketmonFactory.createPocketmon("dragon");
        Pocketmon pocketmon2 = pocketmonFactory.createPocketmon("ghost");
        Pocketmon pocketmon3 = pocketmonFactory.createPocketmon("fighter");

        System.out.println(pocketmon1.getName());
        System.out.println(pocketmon2.getName());
        System.out.println(pocketmon3.getName());

    }
}
```

#### 실행 결과

![image](https://user-images.githubusercontent.com/22395934/79582289-889d0480-8106-11ea-851e-408eb33a145e.png)

인스턴스 생성을 콘크리트 클래스로 위임한 결과입니다. 최종 메인 메서드에서는 new 키워드를 사용하여 인스턴스를 생성한 부분이 없는 것을 확인 할 수 있습니다. 이를 통해 메인 프로그램에서는 어떤 객체가 생성되었는지 신경 쓸 필요 없이 반환된 객체만 사용하면 되고 슈퍼 클래스에서 변경이 발생해도 메인 프로그램이 변경되는 것은 최소화 할 수 있습니다.


##### 참조: https://woovictory.github.io/2019/02/07/Design-Pattern-Factory-Pattern/


## 추상 팩토리 패턴

다음은 추상 팩토리 패턴에 관한 예시입니다. 추상 팩토리 패턴은 인터페이스를 이용하여 서로 연관된, 또는 의존하는 객체를 구상 클래스를 지정하지 않고도 생성할 수 있다고 했습니다. 즉, 연관된 서브 클래스를 그룹화할 수 있고 이 그룹을 자유롭게 교체할 수 있는 패턴이라고 할 수 있습니다.


![Untitled Diagram](https://user-images.githubusercontent.com/22395934/79630637-00624200-818e-11ea-9a51-05415c7099f6.png)


PocketmonAbstractFactory 클래스를 작성하고 이를 상속받아 각 포켓몬을 생성하는 팩토리 클래스를 구현합니다.

그리고 PocketmonFactory에서는 이 팩토리를 파라미터로 받아서 최종적으로 생성된 포켓몬을 반환하게 됩니다.

- 추상 팩토리 인터페이스

```java
public interface PocketmonAbstractFactory {
    public Pocketmon createPocketmon();
}
```

- Pocketmon 팩토리 클래스
 
```java
public class DragonFactory implements PocketmonAbstractFactory {

    @Override
    public Pocketmon createPocketmon() {
        return new Mangnanyong("망나뇽");
    }
}

public class GhostFactory implements PocketmonAbstractFactory {

    @Override
    public Pocketmon createPocketmon() {
        return new Pantom("팬텀");
    }
}

public class FighterFactory implements PocketmonAbstractFactory {
    @Override
    public Pocketmon createPocketmon() {
        return new Rukario("루카리오");
    }
}
```


- Factory 실행 클래스 구현

```java
public class FactoryPatternEx {

    public static void main(String[] args) {

        PocketmonFactory factory = new PocketmonFactory();
        
        Pocketmon pocketmon1 = factory.getPocketmon(new DragonFactory());
        Pocketmon pocketmon2 = factory.getPocketmon(new GhostFactory());
        Pocketmon pocketmon3 = factory.getPocketmon(new FighterFactory());

        System.out.println(pocketmon1.getName());
        System.out.println(pocketmon2.getName());
        System.out.println(pocketmon3.getName());

    }
}
```


#### 실행 결과

![image](https://user-images.githubusercontent.com/22395934/79582289-889d0480-8106-11ea-851e-408eb33a145e.png)


위 코드를 보면 PocketmonAbstractFactory 인터페이스의 구현체들이 PocketmonFactory.getPocketmon() 메서드의 파라미터로 넘어와 각 Pocketmon 객체를 반환 받아 사용할 수 있습니다. 이렇게 되면 팩토리 클래스 교체만으로 조금 더 유연하게 기능의 수정, 확장에 대처하게 될 수 있으므로, 객체지향 2법칙인 개방 폐쇄 원칙을 지킬 수 있게 됩니다. 코드상으로는 if-else 구문을 제거하여 조금 더 깔끔하게 코드를 구성할 수 있습니다.



##### 참조: https://woovictory.github.io/2019/02/07/Design-Pattern-Factory-Pattern/


## 상태(State) 패턴

단일 상품을 판매하는 자판기에 들어갈 소프트웨어를 개발해 달라는 요구가 들어왔습니다. 이 자판기의 동작 방식은 아래와 같은 조건으로 동작합니다.

- 동전이 없을 때 동전을 넣으면 자판기 금액 표시란에 금액이 증가하고 제품 선택이 가능합니다.

- 제품 선택이 가능하면 동전을 넣으면 금액이 증가하고 제품 선택이 가능합니다.

- 동전이 없을때 제품을 선택하면 아무런 동작을 하지 않고 동전 없음이라는 표시가 유지됩니다.

- 제품 선택 가능이면 제품을 선택하고 자판기에서 제품을 주고 잔액이 감소합니다. 결과적으로 잔액이 있으면 제품 선택이 가능하고, 없으면 동전이 없다고 표시됩니다.

아래 코드는 자판기 프로그램의 담당자는 조건에 따라 다른 코드를 실행해야 한다는 판단을 하고, 아래와 같이 코드를 작성하였습니다.

```java
public class VendingMachine {

    public static enum State { NOCOIN, SELECTABLE }
    
    private State state = State.NOCOIN;

    public void insertCoin(int coin) {
        
        switch(state) {
            case NOCOIN:
                increaseCoin(coin);
                state = State.SELECTABLE;
                break;
            case SELECTABLE:
                increaseCoin(coin);
                break;
        } 
    }

    public void select(int productId) {
        switch(state) {
            case NOCOIN:
                // 아무것도 하지 않음
                break;
            case SELECTABLE:
                decreaseCoin();
                if(hasNoCoin()) {
                    state = State.NOCOIN;
                }
        }
    }

    ..// increaseCoin, provideProduct, decreaseCoin 구현
}
```

자판기 프로그램을 구현하는 도중에 다음과 같은 새로운 요구사항이 들어왔습니다.

- 자판기에 제품이 없는 경우에는 동전을 넣으면 바로 동전을 되돌려 줍니다.

이 기능을 추가하기 위해 자판기 프로그램은 아래 코드처럼 바뀝니다.

```java
public class VendingMachine {

    public static enum State { NOCOIN, SELECTABLE, SOLDOUT }
    
    private State state = State.NOCOIN;

    public void insertCoin(int coin) {
        
        switch(state) {
            case NOCOIN:
                increaseCoin(coin);
                state = State.SELECTABLE;
                break;
            case SELECTABLE:
                increaseCoin(coin);
                break;
            case SOLDOUT:
                resultCoin();
                break;
        } 
    }

    public void select(int productId) {
        switch(state) {
            case NOCOIN:
                // 아무것도 하지 않음
                break;
            case SELECTABLE:
                decreaseCoin();
                if(hasNoCoin()) {
                    state = State.NOCOIN;
                }
            case SOLDOUT:
                // 아무 것도 하지 않음
        }
    }

    ..// increaseCoin, provideProduct, decreaseCoin 구현
}
```
또 다시, `자동세척` 증일 때에도 동전을 넣으면 바로 돌려줘야 한다는 요구 사항이 추가되었습니다. 이 요구사항을 충족하기 위해 insertCoin() 메서드와 select() 메서드에 또 다른 조건문이 추가될 것입니다.

위 코드에서는 insertCoin() 메서드와 select() 메서드는 동일한 구조의 조건문을 갖고 있습니다. 이는 상태가 많아질수록 복잡해지는 조건문이 여러 코드에서 중복해서 출현하고, 그만큼 코드 변경을 어렵게 만든다는 것을 의미합니다.(예를 들어, 새로운 상태를 추가하거나 기존 상태를 빼려면 모든 조건문을 찾아서 수정해줘야 합니다.)

VendingMachine 클래스의 코드를 다시 한번 살펴보면, 조건문은 다음과 같은 의미를 내포하고 있습니다.

- 상태에 따라 동일한 기능 요청의 처리를 다르게 합니다.

예를 들어, insertCoin() 메서드는 아래 코드와 같이 NOCOIN이냐, SELECTABLE이냐, 또는 SOLDOUT이냐에 따라서 다르게 동작하고 있습니다.

```java
 switch(state) {
    case NOCOIN:
        increaseCoin(coin);
        state = State.SELECTABLE;
        break;
    case SELECTABLE:
        increaseCoin(coin);
        break;
    case SOLDOUT:
         resultCoin();
         break;
} 
```

select() 메서드 역시 insertCoin() 메서드와 동일하게 상태에 따라 다르게 동작합니다. 이렇게 기능이 상태에 따라 다르게 동작해야할 때 사용할 수 있는 패턴이 상태 패턴입니다. 상태 패턴에서는 상태를 아래 그림과 같이 별도 타입으로 분리하고, 각 상태 별로 알맞은 하위타입을 구현합니다.

![Untitled Diagram (1)](https://user-images.githubusercontent.com/22395934/79639873-45f03080-81c9-11ea-8ae9-6f4aa64adc64.png)

상태 패턴에서 중요한 점은 상태 객체가 기능을 제공한다는 점입니다. State 인터페이스는 동전 증가 처리와 제품 선택 처리를 할 수 있는 두 개의 메서드를 정의하고 있습니다. 이 두 메서드는 모든 상태에서 동일하게 적용되는 기능입니다.

콘텍스트 필드는 상태 객체를 갖고 있습니다. 콘텍스트는 클라이언트로부터 기능 실행 요청을 받으면, 상태 객체에 처리를 위임하는 방식으로 구현합니다. 예를 들어, 자판기 기능을 제공하는 VendingMachine 클래스의 insertCoin() 메서드와 select() 메서드는 아래 코드와 같이 State 객체에 처리를 위임하는 방식으로 동작합니다.

```java
// 상태 패턴을 적용한 VendingMachine 구현
public class VendingMachine {

    private State state;

    public VendingMachine() {
        this.state = new NoCoinState();
    }

    public void insertCoin(int coin) {
        state.increaseCoin(coin, this); // 상태 객체에 위임
    }

    public void select(int productId) {
        state.select(productId, this); // 상태 객체에 위임
    }

    public void changeState(State newState) {
        this.state = newState;
    }

    ...// 기타 다른 기능
}
```

state 필드를 NoCooinState 객체로 초기화했는데, NoCoinState 클래스는 아래와 같이 구현했습니다.

```java
public class NoCoinState implements State {

    @Override
    public void increaseCoin(int coin, VendingMachine vm) {
        vm.increaseCoin(coin);
        vm.changeState(new SelectableState());
    }

    @Override
    public void select(int productId, VendingMachine vm) {
        SoundUnit.beep();
    }
}
```

NoCoinState 클래스의 increaseCoin() 메서드는 VendingMachine의 동전 수를 증가시키고, 상태를 SeletableState로 변경합니다. 즉, 동전 없는 상태에서 동전을 넣으면 동전 수를 증가시키고 선택 가능 상태로 변경하는 기능을 제공하는 것입니다. NoCoinState 클래스의 select() 메서드는 에러 음을 발생시킵니다. 이는 동전 없는 상태에서 음료를 선택하면 에러 음을 발생시킨다는 것을 뜻합니다.

NoCoinState 클래스와 유사하게 SelectableState 클래스는 음료 선택이 가능한 상태에서 동전을 넣을 때와 음료를 선택할 때의 자판기 동작 방식을 구현합니다.

```java
public class SelectableState implements State {

    @Override
    public void increaseCoin(int coin, VendingMachine vm) {
        vm.increaseCoin(coin);
    }

    @Override
    public void select(int productId, VendingMachine vm) {
        vm.provideProduct(productId);
        vm.decreaseCoin();

        if(vm.hasNoCoin()) 
            vm.changeState(new NoCoinState());
    }
}
```

NoCoinState 클래스와 SelectableState 클래스를 보면, 상태 패턴을 적용함으로써 VendingMachine 클래스에 구현되어 있는 상태 별 동작 구현 코드가 각 상태의 클래스로 이동함을 알 수 있습니다. 또한, 이 과정에서 VendingMachine 클래스의 코드 구현은 상태 객체에 위임하는 방식으로 단순해집니다.

상태 패턴의 장점은 새로운 상태가 추가되더라도 콘텍스트 코드가 받는 영향은 최소화 된다는 점입니다.

예를 들어, 자판기 예제에서 자판기의 청소 상태 구현을 위해 CleaningState 클래스를 추가하더라도 insertCoin() 메서드와 select() 메서드의 코드는 그대로 유지됩니다.
상태가 많아질수록 조건문을 이용한 방식은 코드가 복잡해져서 유지 보수를 어렵게 만들지만, 상태 패턴의 경우 상태가 많아지더라도 코드의 복잡도는 증가하지 않기 때문에 유지보수에 유리합니다.

상태 패턴의 두 번째 장점은 상태에 따른 동작을 구현한 코드가 각 상태 별로 구분되기 때문에 상태 별 동작을 수정하기가 쉽다는 점입니다. 조건문을 이용한 방식을 사용할 경우 동전 없음 상태의 동작을 수정하려면 각 메서드를 찾아다니면서 수정해줘야 하는 반면에, 상태 패턴을 적용한 경우 동전 없음 상태를 표현하는 NoCoinState 클래스를 수정해 주면 됩니다. 관련된 코드가 한 곳에 모여있기 때문에 안전하고 더 빠르게 구현을 변경할 수 있게 됩니다.

## 상태 변경은 누가?

상태 패턴을 적용할 때 고려할 문제는 콘텍스트의 상태 변경을 누가 하느냐에 대한 것입니다. 상태 변경을 하는 주체는 콘텍스트나 상태 객체 둘 중 하나가 됩니다. 앞서 예제에서는 각 상태객체에서 콘텍스트의 상태를 변경해 주었습니다.

예를 들어, NoCoinState 클래스의 increaseCoin() 메서드는 VendingMachine의 changeState() 메서드를 호출해서 VendingMachine의 상태를 SelectableState로 변경하였습니다.

```java
public class NoCoinState implements State {

    @Override
    public void increaseCoin(int coin, VendingMachine vm) {
        vm.increaseCoin(coin);
        // 상태 객체에서 콘텍스트의 상태 변경
        vm.changeState(new SelectableState());
    }
```

상태 객체에서 콘텍스트의 상태를 변경하려면 콘텍스트의 다른 값에 접근해야 할 때도 있습니다.
예를 들어, SelectableState 클래스의 select() 메서드는 VendingMachine의 상태를 NoCoinState로 변경해야 하는지 여부를 확인하기 위해 VendingMachine의 hasNoCoin() 메서드를 사용하고 있습니다. 이는 상태 객체에서 콘텍스트의 상태를 변경할 수 있는 조건을 확인할 수 있도록 콘텍스트 인터페이스에 메서드를 추가해야한 다는 것을 의미합니다.

```java
public class SelectableState implements State {

    @Override
    public void select(int productId, VendingMachine vm) {
        vm.provideProduct(productId);
        vm.decreaseCoin();
        // 상태 변경을 위해, vm 객체가 동전이 없는지 확인
        if(vm.hasNoCoin()) 
            vm.changeState(new NoCoinState());
    }
```


콘텍스트 상태를 변경할 경우 콘텍스트의 코드가 다소 복잡해질 수 있습니다. 앞서 VendingMachine 클래스 예제에서 콘텍스트가 직접 상태를 변경하도록 VendingMachine 클래스를 수정하면 아래와 같은 코드가 됩니다.

```java
public class VendingMachine {
    private State state;

    public VendingMachine() {
        this.state = new NoCoinState();
    }

      public void insertCoin(int coin) {
        state.increaseCoin(coin, this); 
        if(hasCoin) 
            changeState(new SelectableState()); // 콘텍스트 상태 변경
    }

    public void select(int productId) {
        state.select(productId, this); 
        if(state.isSelectable() && hasNoCoin())
            changeState(new NoCoinState()); // 콘텍스트 상태 변경
    }

    private void changeState(State newState) {
        this.state = newState;
    }

    private boolean hasCoin() {
        ...
    }

    private boolean hasNoCoin() {
        ...
    }
    ...// 기타 다른 기능

}
```

VendingMachine 클래스의 changeState() 메서드, hasNoCoin() 메서드 그리고 hasCoin() 메서드의 접근 범위를 private으로 지정했는데, 그 이유는 상태 객체에서 콘텍스트의 상태를 변경하기 위한 목적으로 이들 메서드에 접근할 필요가 없어졌기 때문입니다. 이제 상태 객체는 자신이 수행해야 하는 작업만 처리하도록 바뀝니다.

```java
public class SelectableState implements State {
    // 콘텍스트가 상태를 변경하므로, 상태 객체는 자신이 할 작업만 처리합니다.
    @Override
    public void select(int productId, VendingMachine vm) {
        vm.provideProduct(productId);
        vm.decreaseCoin();
    }
}
```
콘텍스트의 상태 변경을 누가 할지는 주어진 상황에 맞게 정해주어야 합니다. 먼저 콘텍스트에서 상태를 변경하는 방식은 비교적 상태 개수가 적고 상태 변경 규칙이 거의 바뀌지 않는 경우에 유리합니다. 왜냐하면 상태 종류가 지속적으로 변경되거나 상태 변경 규칙이 자주 바뀔 경우 콘텍스트의 상태 변경 처리가 복잡해질 가능성이 높기 때문입니다. 상태 변경 처리 코드가 복잡해질수록 상태 변경의 유연함이 떨어집니다.

반면에 상태 객체에서 콘텍스트의 상태를 변경할 경우, 콘텍스트에 영향을 주지 않으면서 상태를 추가하거나 상태 변경 규칙을 바꿀 수 있게 됩니다. 하지만 상태 변경 규칙이 여러 클래스에서 분산되어 있기 때문에, 상태 구현 클래스가 많아질수록 상태 변경 규칙을 파악하기가 어려워지는 단점이 있습니다. 또한, 한 상태 클레스에서 다른 상태 클래스에 대한 의존도 발생합니다.

두 방식은 명확하게 서로 상반되는 장단점을 갖고 있기 때문에, 상태 패턴을 적용할 때에는 주어진 상황에 알맞은 방식을 선택해야 합니다.


## 데코레이터(Decorator) 패턴

상속은 기능을 확장하는 방법을 제공합니다. 예를 들어, 데이터를 파일에 출력하는 기능을 제공하는 FileOut 클래스가 있을 때, FileOut 클래스에 버퍼 기능을 추가하거나 압축 기능을 추가하려면 상속을 받아서 기능을 확장해서 구현할 수 있을 것입니다.

상속을 이용한 기능 확장 방법이 쉽긴 하지만, 다양한 조합의 기능 확장이 요구될 때 클래스가 불필요하게 증가하는 문제가 발생합니다. 버퍼 기능과 압축 기능을 함께 제공해야 한다거나, 압축한 뒤 암호화 기능을 제공해야 한다거나, 또는 버퍼 기능과 암호화 기능을 함께 제공해야 한다면, 클래스가 증가하고 계층 구조가 복잡해집니다.

이런 경우 사용할 수 있는 패턴이 데코레이터 패턴입니다. 데코레이터 패턴은 상속이 아닌 위임을 하는 방식으로 기능을 확장해 나갑니다. 위 예제에 데코레이터 패턴을 적용하면 아래 그림과 같이 바뀝니다.

![Untitled Diagram](https://user-images.githubusercontent.com/22395934/79747941-7cec5080-8347-11ea-85a6-89b59c9e12a5.png)


그림에서 FileOut 인터페이스는 파일 출력 기능을 정의하고 있고, 실제 파일 출력 기능은 FileOutImpl 클래스가 구현하고 있습니다. 여기서 중요한 점은 기능 확장을 위해 FileOutImpl 클래스를 상속받지 않고, Decorator라고 불리는 별도의 추상 클래스를 만들었다는 점입니다.

Decorator 클래스는 모든 데코레이틀 위한 기반 기능을 제공하는 추상 클래스로서 코드는 아래와 같습니다. 이 클래스의 doDelegate() 메서드는 생성자를 통해서 전달받은 FileOut 객체에 쓰기 기능을 위임합니다.

```java
public abstract class Decorator implements FileOut {

    private FileOut delegate; // 위임 대상

    public Decorator(FileOut delegate) {
        this.delegate = delegate;
    }

    protected void doDelegate(byte[] data) {
        delegate.write(data); // delegate 쓰기 위임
    }
}
```

BufferdOut 클래스, EncryptionOut 클래스, ZipOut 클래스는 모두 데코레이터 클래스로서 Decorator 클래스를 상속받고 있습니다. 이들 클래스는 자신의 기능을 수행한 뒤에 상위 클래스의 doDelegate() 메서드를 이용해서 파일 쓰기를 위임하도록 구현하빈다. 예를 들어, EncryptionOut 클래스는 아래와 같이 구현할 수 있습니다.

```java
// EncrpytionOut 클래스
public class EncryptionOut extends Decorator {

    public EncryptionOut(FileOut delegate) {
        super(delegate);
    }

    public void write(Byte[] data) {
        byte[] encryptedData = encrypt(data);
        super.doDelegate(encryptedData);
    }

    private byte[] encrpyt(byte[] data) {
        ...
    }

}
```
EncryptionOut 클래스의 write() 메서드는 파일에 쓸 데이터를 암호호한 뒤에, doDelegate() 메서드를 이용해서 암호화된 데이터를 delegate 객체에 전달합니다. BufferedOut 클래스와 ZipOut 클래스도 비슷한 방식으로 구현합니다.

이제 파일에 데이터를 암호화해서 쓰는 기능이 필요한 곳의 코드를 만들어 봅시다. 이 코드는 다음과 같이 FileOut 객체를 이용해서 EncryptionOut 객체를 생성한 뒤에, EncryptionOut 객체의 writ() 메서드를 실행합니다.

```java
FileOut delegate = new FileOutImpl();
FileOut fileOut = new EncryptionOut(delegate);
fileOut.write(data);
```

EncryptionOut의 write() 메서드를 실행하면 EncryptionOut의 write() 메서드에서 데이터를 암호화하고, FileOutImpl 객체의 write() 메서드에 암호화 된 데이터를 전달하게 됩니다. 여기서 EncryptionOut 객체는 FileOutImpl 객체가 제공하는 파일 쓰기 기능에 암호화 기능을 추가해 주는 역할을 수행하게 되며, 기존 기능에 새로운 기능을 추가해 준다는 의미에서 EncrpytionOut 객체를 데코레이터라고 부릅니다.

데코레이터 패턴의 장점은 데코레이터를 조합하는 방식으로 기능을 확장할 수 있다는 데에 있습니다.

```java
FileOut delegate = new FileOutImpl();
FileOut fileOut = new EncryptionOut(new ZipOut(delegate));
fileOut.wirte(data);
```

기능 적용 순서의 변경도 쉽습니다. 아래 코드처럼 데코레이터 생성 순서를 변경해 주기만 하면 됩니다.

```java
// 버퍼 -> 암호화 -> 압축 -> 파일 쓰기
FileOut fileOut = new BufferedOut(EncryptionOut(new ZipOut(delegate)));

// 암호화 -> 압축 -> 버퍼 -> 파일 쓰기
FileOut fileOut = new EncryptionOut(new ZipOut(new BufferedOut(delegate)));
```

데코레이터 패턴을 사용하면 각 확장 기능들의 구현이 별도의 클래스로 분리되기 때문에, 각 확장 기능 및 원래 기능을 서로 영향 없이 변경할 수 있도록 만들어 줍니다. FileOutImpl 클래스의 구현을 변경하더라도 EncryptionOut 클래스가 내부 암호화 알고리즘을 변경하더라도 다른 데코레이터나 FileOutImpl 클래스는 영향을 받지 않습니다. 즉, 데코레이터 패턴은 단일 책임 원칙을 지킬수 있도록 만들어 줍니다.

데코레이터 패턴은 전략 패턴/템플릿 메서드 패턴/상태 패턴과 함께 매우 흔하게 사용되는 패턴입니다. 스프링 프레임워크의 경우 트랜잭션 처리를 위해 데코레이터 패턴을 사용합니다. 스프링 프레임워크에서 트랜잭션 관련 설정을 추가하면, 아래 그림과 같이 트랜잭션 기능이 추가된 데코레이터 객체를 런타임에 생성합니다.

![Untitled Diagram (1)](https://user-images.githubusercontent.com/22395934/79755270-d2c6f580-8353-11ea-8769-d18f7fb156d9.png)

스프링 프레임워크는 데코레이터를 이용해서 트랜잭션을 처리합니다.

## 데코레이터 패턴을 적용할 때 고려할 점
데코레이터 패턴을 구현할 때 고려할 점은 데코레이터 대상이 되는 타입의 기능 개수에 대한 것입니다. 앞서 예제에서 데코레이터 대상이 되는 FileOut 타입은 write() 메서드가 한 개만 정의되어 있어 데코레이터 구현이 비교적 간단하지만, 정의되어 있는 메서드가 증가하게 되면 그만큼 데코레이터의 구현도 복잡해집니다.

데코레이터 구현에서 고려해야 할 또 다른 사항은 데코레이터 객체가 비정상적으로 동작할 때 어떻게 처리할 것이냐에 대한 것입니다.

예를 들어, 게시글 작성 이후 생성된 게시글 데이터를 외부 메시지 서버에 전송해 주는 기능을 별도의 데코레이터로 구현했다고 합시다. 이 경우 런타임의 객체 간 메시지 흐름은 아래와 같습니다.

![Untitled Diagram (2)](https://user-images.githubusercontent.com/22395934/79756385-84b2f180-8355-11ea-93da-4cea7481597c.png)

외부의 메시지 서버에 장애가 발생하면, 위 그림의 실행 흐름에서 6번 과정에 문제가 발생하게 됩니다. 하지만, 1~5번까지의 과정은 정상적으로 실행이되어 트랜잭션이 커밋되었기 때문에 DB에는 새로운 데이터가 정상적으로 추가됩니다. 이 경우 6번 과정의 문제가 발생했다고 해서 클라이언트에 익셉션을 발생시키는 것은 올바른지 고민해 봐야합니다. 왜냐하면 클라이언트가 요구하는 기능인 게시글 등록 자체는 정상적으로 실행되었기 때문입니다.

이런 경우 메시지 전송 데코레이터는 외부 메시지 서버에 데이터 전송에 실패하더라도 익셉션을 발생시키지는 대신 실패 로그를 남기는 방법을 선택할 수 있습니다. 이렇게 함으로써 외부 메시지 서버 연동에 실패하더라도 클라이언트는 에러 결과가 아닌 정상 결과를 볼 수 있으며, 향후에 실패 로그를 이용해서 데이터 재전송 같은 사후 처리를 할 수 있게 됩니다.

데코레이터의 단점은 사용자 입장에서 데코레이터 객체와 실제 구현 객체의 구분이 되지 않기 때문에 코드만으로는 기능이 어떻게 동작하는지 이해하기가 어렵습니다.

예를 들어, 아래 코드에서 writeTo() 메서드는 파라미터로 전달 받은 FileOut 객체를 사용하는데, writeTo() 메서드는 이 FileOut 객체가 단순히 파일에 쓰기만 하는지 아니면 압추을 하는지 등의 여부를 알 수 없습니다. 실제로 FileOut 객체가 어떻게 동작하는지 알려면 런타임에 생성된 객체의 구조를 이해해야 합니다.


```java
public class ImageSource {

    public void writeTo(FileOut out) {
        out.write(imageData);
    }
}
```

## 프록시(proxy) 패턴

제품 목록을 보여주는 GUI 프로그램은 아래 그림처럼 목록 중 일부를 화면에 보여주고, 스크롤을 할 때 나머지 목록을 화면에 표시할 수 있습니다.

![Untitled Diagram (3)](https://user-images.githubusercontent.com/22395934/79984399-10f31f00-84e4-11ea-8001-83c13bff11e7.png)

제품 목록을 구성할 때 관련된 모든 이미지를 로딩하도록 구현할 수 있는데, 이 경우 블필요하게 메모리를 사용하는 문제가 발생할 수 있습니다.

예를 들어, 목록 하단에 위치한 이미지는 실제로 스크롤을 하기 전까지는 화면에 보이지 않음에도 불구하고 목록을 구성할 때 메모리에 이미지 정보를 로딩하게 됩니다. 특히 이미지를 로컬 파일 시스템이 아닌 웹에서 읽어 온다면 이미지 로딩으로 인해 제품 목록을 보여주기 까지 대기 시간이 길어지게 됩니다.

불필요한 이미지 로딩에 따른 메모리 낭비와 이미지 로딩에 따른 화면 출력 대기 시간이 길어지는 문제를 해결하는 방법은 이미지가 실제로 화면에 보여질 때 이미지 데이터를 로딩하는 것입니다. 이미지가 필요할 때 이미지 데이터를 로딩하는 기능을 추가하는 가장 쉬운 방법은 필요 시점에 Image 클래스를 이용해서 이미지를 로딩하는 DynamicLoadingImage 클래스를 추가하고, 아래 그림과 같이 목록을 보여주는 클래스에서 Image 클래스 대신 DynamicLoadingImage를 사용하게 만드는 것입니다.

![Untitled Diagram](https://user-images.githubusercontent.com/22395934/79984978-dfc71e80-84e4-11ea-95c9-aa61273cb12b.png)


하지만, 위 그림과 같이 구현하게 되면, 이미지 로딩 방식을 변경해야 할 때 ListUI 코드를 변경해야 하는 문제가 발생합니다. 예를 들어, 화면에 보여줄 목록의 개수가 5개 미만이면 바로 로딩하고 5개 이상이면 동적으로 로딩하도록 구현해야 할 때 ListUI 코드는 Image 클래스와 DynamicLoadingImage 클래스를 구분하는 조건문을 갖게 될 것입니다.

이런 상황에서 ListUI 변경 없이 이미지 로딩 방식을 교체할 수 있도록 해주는 패턴이 프록시 패턴입니다. 프록시 패턴은 실제 객체를 대신하는 프록시 객체를 사용해서 실제 객체의 생성이나 접근 등을 제어할 수 있도록 해 주는 패턴으로서, 구조는 아래 그림과 같습니다.


![Untitled Diagram (1)](https://user-images.githubusercontent.com/22395934/79986876-a93ed300-84e7-11ea-81ed-70f601f90f48.png)

위 그림에서 Image 인터페이스는 이미지를 표현하며 ListUI는 Image 타입을 이용해서 화면에 이미지를 표시합니다. RealImage 클래스는 실제로 이미지 데이터를 로딩해서 메모리에 보관하는 콘크리트 클래스입니다. 여기서 중요한 건 ProxyImage 클래스입니다.

PrxoyImage 클래스가 프록시 패턴에서 프록시 역할을 하는데, ProxyImage 클래스는 아래 코드처럼 구현됩니다.

```java
public class ProxyImage implements Image {

    private String path;
    private RealImage image;

    public ProxyImage(String path) {
        this.path = path;
    }

    public void draw() {
        if(image == null) {
            image =new RealImage(path); // 최초 접근 시 객체 생성
        }
        image.draw();
    }
}
```
ProxyImage 클래스는 draw() 메서드가 호출되기 전까지 RealImage 객체를 생성하지 않습니다. ProxyImage 클래스의 draw() 메서드는 최초로 draw() 메소드를 실행할 때 RealImage 객체를 생성하고, 그 뒤로 생성된 RealImage 객체의 draw() 메서드를 호출합니다.

ListUI 클래스는 Image 타입을 사용하기 때문에 실제 타입이 RealImage 인지 PrxoyImage인지 여부는 모릅니다. 단지, Image 타입의 draw() 메서드를 이용해서 이미지를 그려 달라고 할 뿐입니다. ListUI 클래스가 다음과 같이 Image 타입의 목록을 가지고 있고, 스크롤이 되는 시점에 해당 Image 객체의 draw() 메소드를 호출한다고 합시다.

```java
public class ListUI {
   
    private List<Image> images;
   
    public ListUI(List<Image> images) {
        this.images = images;
    }

    // 스크롤 시, 화면에 표시되는 이미지를 표시
    public void onScroll(int start, int end) {
        for(int i = start; i <= end; i++) {
            Image image = images.get(i);
            image.draw();
        }
    }
}
```

ListUI 클래스의 images 필드에 보관된 Image 객체의 실제 타입이 ProxyImage인 경우, 위 코드의 onScroll() 메서드에서 이미지를 그리는 과정은 다음과 같이 동작하게 됩니다.

PrxoyImage 객체는 최초에 draw() 메서드가 실행될 때 RealImage 객체를 생성하기 때문에, ProxyImage 객체의 draw() 메서드가 호출되기 전에는 RealImage 객체를 생성되지 않으므로 메모리에 이미지 데이터를 로딩하지 않습니다. 따라서 화면에 표시되지 않는 이미지를 로딩하기 위해 불필요하게 메모리를 낭비하는 상황을 방지할 수 있게 됩니다.

또한, ListUI 클래스는 이미지가 언제 로딩되는지 알 필요가 없기 때문에, 이미지 로딩 정책을 변경하더라도 ListUI 클래스의 코드는 영향을 받지 않습니다.

예를 들어, 상위 4개는 바로 이미지를 로딩하고 나머지는 화면에 보여지는 순간에 로딩하도록 구현해야 할 경우 다음 코드처럼 RealImage 객체와 PrxoyImage 객체를 섞어서 ListUI에 전달해 주면 됩니다.

```java
List<String> paths = ...
List<Image> images = new ArrayList<Image> (paths.size());
for(int i = 0; i < paths.size(); i++){
    if (i < 4) {
        images.add(new RealImage(paths.get(i)));
    } else {
        images.add(new ProxyImage(paths.get(i)));
    }
}
// 이미지 로딩 정책의 변경이 ListUI에 영향을 주지 않습니다.
ListUI listUI = new ListUI(images);
```

ProxyImage처럼 필요한 순간에 실제 객체를 생성해 주는 프록시를 가상 프록시라고 부르는데, 프록시에는 가상 프록시 외에 보호 프록시나 원격 프록시 등이 존재합니다. 보호 프록시는 실제 객체에 대한 접근을 제어하는 프록시로서, 접근 권한이 있는 경우에만 실제 객체의 메서드를 실행하는 방식으로 구현합니다. 원격 프록시는 RMI(Remote Method Invocation)처럼 다른 프로세스에 존재하는 객체에 접근할 때 사용되는 프록시입니다. 원격 프록시는 내부적으로 IPC(Inter process communication)이나 TCP 통신을 이용해서 프로세스의 객체를 실행하게 됩니다.

## 프록시 패턴을 적용할 때 고려할 점
프록시를 구현할 때 고려할 점은 실제 객체를 누가 생성할 것이냐에 대한 것입니다.
PrxoyImage와 같은 가상 프록시는 필요한 순간에 실제 객체를 생성하는 경우가 많기 때문에, ProxyImage 클래스에서 직접 RealImage 타입을 사용한 것처럼 가상 프록시에서 실제 생성할 객체의 타입을 사용하게 됩니다. 반면에 접근 제어를 위한 목적으로 사용되는 보호 프록시는 보호 프록시 객체를 생성할 때 실제 객체를 전달하면 되므로, 실제 객체의 타입을 알 필요 없이 추상화 타입을 사용하면 됩니다.

위임 방식이 아닌 상속을 사용해서 프록시를 구현할 수도 있습니다. 예를 들어, 특정 기능은 관리자만 실행할 수 있어야 한다고 할 경우 프록시를 사용할 수 있을 것입니다.

이대 보호 프록시는 다음과 같이 상위 클래스의 메서드를 제정의하는 방법으로 구현할 수 있습니다.

```java
public class ProtectedService extends Service {

    @Override
    public void someMethod() {
        if(! CurrentContext.getAuth().isAdmin()) 
            throw new AccessDeniedException();

        super.someMethod();        
    }
}
```

상속 방식을 사용하면 위임 방식에 비해 구조가 단순해서 구현이 비교적 쉽습니다. 하지만, 상속 방식의 프록시는 객체를 생성하는 순간 실제 객체가 생성되기 때문에 가상 프록시를 구현하기에는 적합하지 않습니다.

> 위임 기반의 프록시 패턴 구현은 앞서 살펴본 데코레이터 패턴의 구현과 매우 유사한데, 이 두 패턴은 의도에서 분명한 차이를 보입니다. 프록시 패턴의 경우 실제 객체에 대한 접근을 제어하는데 초점이 맞춰져 있는 반면에 데코레이터 패턴은 기존의 객체의 기능을 확장하는데 초점을 맞추고 있습니다. 따라서 클래스의 이름을 부여할 때에는 의도에 맞는 단어를 선택해야 합니다.


## 어댑터 패턴
웹 게시판에 통합 검색 기능을 추가해 달라는 요구가 들어와서 DB를 이용해서 검색 기능을 구현하기로 결정한 상황을 생각해 봅시다. 통합 검색 기능을 정의하기 위해 아래 그림과 같이 SearchService 인터페이스를 작성하고, DB를 이용한 DBSearchService 클래스를 구현하였습니다.

![Untitled Diagram (2)](https://user-images.githubusercontent.com/22395934/80111163-7e717f00-85ba-11ea-99b4-4d0ca07597e6.png)

게시글의 개수가 빠르게 증가하면서 SQL의 like를 이용한 검색 속도 성능에 문제가 발생하기 시작했습니다. 검색 속도의 문제를 해결하기 위해 Tolr라는 오픈 소스 검색 서버를 도입하기로 결정했습니다. Tolr 자료를 확인한 프로그래머는 별도로 제공하는 TolrClient 모듈을 사용하면 Tolr와 쉽게 연동할 수 있다는 것을 알게 되었습니다.

문제는 아래 그림에서 보듯이 TolrClient가 제공하는 인터페이스와 SearchService 인터페이스가 맞지 않다는 점입니다. WebSearchRequestHandler 클래스를 비롯해서 여러 클래스가 SearchService를 사용하도록 만들어졌기 때문에, SearchService 대신 TolrClient를 사용하도록 변경하는 작업은 많은 변경을 요구합니다.

![Untitled Diagram (1)](https://user-images.githubusercontent.com/22395934/80114012-f8efce00-85bd-11ea-839d-0c946c31beb0.png)

이렇게 클라이언트(WebSearchRequestHandler)가 요구하는 인터페이스와 재사용하려는 모듈의 인터페이스가 일치하지 않을 때 사용할 수 있는 패턴이 어댑터(Adapter) 패턴입니다. 인터페이스가 맞지 않는 문제를 해결하기 위해 어댑터 패턴을 적용하면 아래 그림과 같은 구조를 갖게 됩니다.

![Untitled Diagram](https://user-images.githubusercontent.com/22395934/80116112-86342200-85c0-11ea-9660-746cde5814b8.png)

위 글에서 어댑터에 해당하는 SearchServiceTolrAdapter 클래스는 TolrClient를 SearchService 인터페이스에 맞춰 주는 책임을 갖습니다. SearchServiceTolrAdapter 클래스의 search() 메서드는 아래 코드에서 보듯이 TolrClient 객체를 실행하고 그 결과를 SearchService 인터페이스에 맞는 리턴타입으로 변환해 줍니다.

```java
// TolrClient를 SearchService에 맞춰주는 객체 위임 방식 어댑터 구현
public class SearchServiceAdapter implements SearchService {

    private TolrClient tolrClient = new TolrClient();

    public SearchResult search(String keyword) {
        // keyword를 tolrClient가 요구하는 형식으로 변환.
        TolrQuery tolrQuery = new TolrQuery(keyword);
        // TolrClient 기능 실행
        QueryResponse response = tolrClient.query(tolrQuery);
        SearchResult result = convertToResul(response);
        return result;
    }

    private SearchResult convertToResult(QueryResponse response) {
        List<TolrDocument> tolrDocs = response.getDocumentList().getDocuments();
        List<SearchDocument> docs = new ArrayList<SearchDocument> ();
        for(TolrDocument tolrDoc: tolrDocs) {
            docs.add(new SearchDocument(tolrDoc.getId(), ...);
        }
        return new SearchResult(docs);
    }
}
```

SearchServiceTolrAdapter 클래스는 SearchService 인터페이스를 구현하고 있으므로, WebSearchRequestHandler 클래스의 코드 수정 없이 DB 기반 통합 검색에서 TolrClient를 이용한 통합 검색으로 구현을 변경할 수 있게 됩니다.

어댑터 패턴이 적용된 예는 SLF4J라는 로깅 API 입니다.  SLF4J는 단일 로깅 API를 사용하면서 자바 로깅, log4j, LogBack 등의 로깅 프레임워크를 선택적으로 사용할 수 있도록 해주는데, 이 때 SLF4J가 제공하는 인터페이스와 각 로깅 프레임워크를 맞춰 주기 위해 어댑터를 사용하고 있습니다.

![Untitled Diagram (2)](https://user-images.githubusercontent.com/22395934/80300624-53b14180-87d9-11ea-853b-904b60197912.png)


어댑터 패턴은 개방 페쇄 원칙을 따를 수 있도록 도와줍니다. 위 그림에서 로깅 프레임 워크를 LogBack으로 교체하고 싶다면 LogBack을 slf4j-api 패키지의 Logger로 맞춰주는 새로운 어댑터만 구현해 주면 됩니다.

이 과정에서 slf4j-api 패키지의 Logger를 사용하는 코드는 전혀 영향을 받지 않습니다.

앞서 SearchServiceTolrAdapter 클래스는 TolrCliet를 조립하는 방법으로 구현했는데, TolrClient를 사옷ㄱ받는 방법으로 어댑터를 구현할 수도 있습니다.

![Untitled Diagram](https://user-images.githubusercontent.com/22395934/80300819-d25aae80-87da-11ea-8d9b-3cda24d88bd0.png)

상속을 이용해서 어댑터를 구현하는 경우, SearchServicTolrAdapter 클래스의 search() 메서드는 상위 클래스인 TolrClient에 정의된 메서드를 호출하는 방식으로 코드를 작성하게 됩니다. 아래 코드는 상속을 이용한 어댑터 패턴의 구현 예입니다.

```java
public class SearchTolrAdapter extends TolrClient implements SearchService {

    public SearchResult search(String keyword) {
        // keyword를 tolrClient가 요구하는 형식으로 변환
        TolrClient tolQuery = new TolrQuery(keyword);
        //TolrClient 기능 실행
        QueryResponse response = super.query(tolrQuery);
        //TolrClient의 결과를 SearchResult로 변환
        SearchResult result = convertResult(response);
        return result;
    }

    private SearchResult convertResult(QueryResponse response) {
        List<TolrDocument> tolDocs = response.getDocumentList().getDocuments();

        List<SearchDocument> docs = new ArrayList<SearchDocument> ();

        for(TolrDocument tolrDocument : tolDocs) {
            docs.add(new SearchDocument(tolrDocument.getId(), ...));
        }
        return new SearchResult(docs);
    }
}
```

클라이언트가 사용하는 SearchService가 인터페이스가 아닌 일부 구현이 포함된 추상 클래스라면, 자바와 같이 클래스 단일 상속만을 지원하는 언어에서는 클래스의 상속을 이용한 어댑터 구현에 제약을 받게 됩니다.


## 옵저버(Observer) 패턴
웹 사이트의 상태를 확인해서 응답 속도가 느리거나 연결이 안 되면 모니터링 담당자에게 이메일로 통지해 주는 시스템을 만들기 위해, 상태를 확인하는 StatusChecker 클래스를 다음과 같이 구현할 수 있을 것입니다.

```java
publc class StatusChecker {
    private EmailSender emailSender;

    public void check() {
        Status status = loadStatus();

        if(status.isNotNormal())
            eamilSender.sendEmail(status);
    }
}
```

이메일뿐만 아니라 긴급한 메시지는 SMS로 바로 알려주는 기능을 추가해 달라는 요구가 들어왔습니다. 이를 반영하기 위해 코드는 다음과 같이 바뀝니다.

```java
public class StatusChecker {

    private EmailSender emailSender;
    private SmsSender smsSender;

    public void check() {
        Status status = loadStatus();
        if(status.isNotNormal()) {
            emailSender.sendEmail(status);
            smsSender.sendEmail(status);
        }
    }
}
```

만약 회사 내부에서 사용하는 메신저로도 메시지를 보내 달라는 요구가 들어온다면 어떻게 될까요? 시스템의 문제 상황을 알려주는 방식이 추가될 때마다, StatusChecker 클래스도 아래 그림처럼 변경됩니다.

![Untitled Diagram (1)](https://user-images.githubusercontent.com/22395934/80308952-c38cef80-880c-11ea-9a9d-6e88e5531383.png)


StatusChecker는 시스템의 상태가 불안정해지면 이 사실을 EmailSender, SmsSender, Messenger 객체에게 알려주는데, 여기서 핵심은 상태가 변경될 때 정해지지 않은 임의의 객체에게 변경 사실을 알려준다는 점입니다. 이렇게 한 객체의 상태 변화를 정해지지 않는 여러 다른 객체에게 통지하고 싶을 때 사용되는 패턴이 옵저버(Observer) 패턴 입니다.

![Untitled Diagram](https://user-images.githubusercontent.com/22395934/80309198-714cce00-880e-11ea-8358-4b3ecb1720ef.png)

옵저버 패턴은 크게 주제(subject) 객체와 옵저버(observer) 객체가 등장하는데, 주제 객체는 다음과 두 가ㅏ지 책임을 갖습니다.

- 옵저버 목록을 관리하고, 옵저버를 등록하고 제거할 수 있는 메서드를 제공합니다. 위 그림에서 add() 메서드와 remove() 메서드가 각각 옵저버를 목록에 등록하고 삭제하는 기능을 제공합니다.

- 상태의 변경이 발생하면 등록된 옵저버에 변경 내역을 알립니다. 위 그림에서 notifyStatus() 메서드가 등록된 옵저버 객체의 onAbnormalStatus() 메서드를 호출합니다.

StatusSubject 클래스는 아래 코드와 같이 옵저버 목록을 List와 같은 타입으로 보간할 수 있을 것입니다.

```java
public abstract class StatusSubject {
    private List<StatusObserver> observers = new ArrayList<StatusObserver> ();

    public void add(StatusObserver observer) {
        observers.add(observer);
    }

    public void remove(StatusObserver observer) {
        observers.remove(observer);
    }

    public void notifyStatus(Status status) {
        for(StatusObserver observer : observers) {
            observer.onAbnormalStatus(status);
        }
    }
}
```

notifyStatus() 메서드는 observers List에 등록된 각 StatusObserver 객체의 onAbnormalStatus() 메서드를 호출하는데, 이렇게 옵저버 객체의 메서드를 호출하는 방식으로 상태에 변화가 생겼음을 옵저버 객체에게 알립니다.

Status의 상태 변경을 알려야 하는 StatusChecker 클래스는 아래 코드와 같이 StatusSubject 클래스를 상속받아 구현합니다.

```java
public class StatusChecker extends StatusSubject {

    public void check() {
        Status status = loadStatus();

        if(status.isNotNormal()) {
            super.notifyStatus(status);
        }
    }

    private Status loadStatus() {
        ...
    }
}
```

StatusChecker 클래스는 비정상 상태가 감지되면 상위 클래스의 notifyStatus() 메서드를 호출해서 등록된 옵저버 객체들에 상태 값을 전달합니다.

옵저버 객체를 구현한 클래스는 주제 객체가 호출하는 메서드에서 필요한 기능을 구현하면 됩니다. 위 예제 코드의 경우 StatusSubject 타입 객체에 등록되는 옵저버 인터페이스인 StatusObserver는 아래 코드와 같이 주제 객체로부터 상태 변화를 전달받을 수 있는 메서드인 onAbnormalStatus() 메서드를 정의하고 있습니다.

옵저버 구현 클래스인 StatusEmailSender 클래스는 아래 코드처럼 StatusObserver 인터페이스를 상속받아 상태 변화를 통지 받을 때 수행해야 할 기능을 구현하게 됩니다.

```java
public interface StatusObserver {

    void onAbnormalStatus(Status status);

}
```

### 콘크리트 옵저버 클래스 구현 예

```java
public class StatusEmailSender implements StatusObserver {

    @Override
    public void onAbnormalStatus(Status status) {
        sendEmail(status);
    }

    private void sendEmail(Status status) {
        ... // 이메일 전송 코드
    }
}
```


주제 객체의 상태에 변화가 생길 때 그 내용을 통지받도록 하려면, 옵저버 객체를 주제 객체에 등록해 주어야 합니다.
예를 들어, 시스템의 상태가 비정상이 될 때 StatusChecker 객체가 StatusEmailSender 객체에 통지하게 하려면 다음 코드처럼 StatusEmailSender 객체를 StatusChecker 객체에 옵저버로 등록해 주어야 합니다.

```java
StatusChecker checker = new StatusChecker();
checker.add(new StatusEmailSender()); // 옵저버로 등록
```   

위와 같이 옵저버로 등록되면, 시스템이 비정상 상태가 될 때마다 StatusChecker 객체가 StatusEmailSender 객체의 onAbnormalStatus() 메서드를 호출해서 상태 정보를 통지해줍니다. 따라서 StatusEmailSender 객체는 시스템이 비정상 상태가 될 때 담당자에게 이메일로 통보해 줄 수 있게 됩니다.

옵저버 패턴을 적용할 때의 장점은 주제 클래스 변경 없이 상태 변경을 통지 받을 옵저버를 추가할 수 있다는 점입니다.
예를 들어, 장애가 발생할 때 SMS를 이용해서 문자를 전송하고 싶다면, 해당 기능을 구현한 옵저버 객체를 StatusChecker 객체에 등록해 주기만 하면 됩니다.

```java
StatusChecker checker = ...;

// 새로운 타입의 옵저버가 추가되어도 StatusChecker 코드는 바뀌지 않습니다.
StatusObserver faultObserver = new FaultStatusSMSSender();
checker.add(faultObserver);
checker.add(new StatusEmailSender());
```

## 옵저버 객체에게 상태 전달 방법

옵저버 객체가 기능을 수행하기 위해 주제 객체의 상태가 필요할 수 있습니다. 예를 들어, FaultStatusSMSSender 클래스는 장애 상태인 경우에만 SMS를 전송하고, 응답 속도가 느려진 상태처럼 장애 이외의 비정상 상태인 경우에는 메시지를 전송하지 않도록 구현할 수 있을 것입니다. 이 경우 FaultStatusSMSendr 클래스는 상태 값을 확인해야 합니다. 지금까지 작성한 예에서는 아래 코드에서 보듯이 주제 객체에서 옵저버 객체에 상태 값을 전달했습니다.

```java
public abstract class StatusSubject {
    private List<StatusObserver> observers = new ArrayList<StatusObserver> ();
    ...
    public void notifyStatus(Status status) {
        for (StatusObserver observer: observers) 
            observer.onAbnormalStatus(status); // 상태를 옵저버에 전달
        
    }
}
    // 옵저버는 파라미터로 전달받은 상태 값을 사용
public class FaultStatusSMSSender implements StatusObserver {
    public void onAbnormalStatus(Status status) {

        if(status.isFault()) { // 전달 받은 상태 값을 사용
            sendSMS(status);
        }
    }
    ...
}


```

위 코드에서 FaultSMSSender 클래스는 onAbnormalStatus() 메서드를 통해서 전달 받은 status 객체만으로 원하는 기능을 구현하는데 부족함이 없습니다. 하지만, 경웨 따라서 옵저버 객체의 메서드를 호출할 때 전달한 객체만으로는 옵저버의 기능을 구현할 수 없을 수도 있습니다.

이런 경우에는 옵저버 객체에서 콘크리트 주제 객체에 직접 접근하는 방법을 사용하기도 합니다. 아래 코드는 옵저버 객체에서 특정 타입의 주제 객체를 사용하는 코드의 예를 보여주고 있습니다.

```java
public class SpecialStatusObserver implements StatusObserver {
    private StatusChecker statusChecker;
    private Siren siren;

    public SpecialStatusObserver(StatusChecker statusChecker) {
        this.statusChecker = statusChecker;
    }

    public void onAbnormalStatus(Status status) {
        // 특정 타입의 주제 객체 접근
        if(status.isFault() && statusChecker.isContinuousFault()) {
            siren.begin();
        }
    }
}
```
SpecialStatusObserver 클래스의 onAbnormalStatus() 메서드는 status 파라미터와 statusChecker 필드를 이용해서 사이렌의 실행 조건을 판단하고 있습니다.

이 코드를 보면 아래 그림처럼 SpecialStatusObserver 클래스에서 StatusChecker 클래스로의 의존이 발생하게 되는데, 이렇게 콘크리트 옵저버 클래스(SpecialStatusObserver)는 필요에 따라 특정한 콘크리트 주제 클래스(StatusChecker)에 의존하게 됩니다.

![Untitled Diagram (2)](https://user-images.githubusercontent.com/22395934/80496985-d508ff80-89a4-11ea-8553-f24821abf478.png)

## 옵저버에서 주제 객체 구분

옵저버 패턴이 가장 많이 사용되는 영역을 꼽르라면 GUI 프로그래밍 영역일 것입니다. 버튼이 눌릴 때 로그인 기능을 호출한다고 할 때, 버튼이 주제 객체가 되고 로그인 모듈을 호출하는 객체가 옵저버가 됩니다.

예를 들어, 안드로이드에서는 다음과 같이 OnClickListener 타입의 객체를 Button 객체에 등록하는데, 이 때 OnClickListener 인터페이스가 옵저버 인터페이스가 됩니다.

```java
public class MyActivity extends Activity implements View.OnClickListener {

    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);
        ...
        Button loginButton = getViewById(R.id.main_login);
        loginButton.setOnClickListener(this);
    }

    @Override
    public void onClick(View v) { // OnClickListener의 메서드
        login(id, password);
    }
}
```

한 개의 옵저버 객체를 여러 주제 객체에 등록할 수도 있을 것입니다. GUI 프로그래밍을 하면 이런 상황이 빈번하게 발생합니다.


예를 들어, 아래 코드처럼 로그인 버튼과 로그아웃 버튼에 동일한 OnClickListener 객체를 등록할 수 있습니다.

```java
public class MyActivity extends Activity implements View.OnClickListener {

    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);
        ...
        // 두 개의 버튼에 동일한 onClickListener 객체 등록
        Button loginButton = getViewById(R.id.main_login);
        loginButton.setOnClickListener(this);
        Button logoutButton = (Button) findViewById(R.id.main_logoutbtn);
        logoutButton.setOnClickListener(this);
    }

    @Override
    public void onClick(View v) { // OnClickListener의 메서드
        
        if (v.getId() == R.id.main_loginbtn) {
            login(id, password);    
        } else if (v.getId() == R.id.main_logoutbtn) {
            logout();
        }
    }
}
```

한 옵저버 객체를 여러 주제 객체에 등록하면, 옵저버 객체에서 각 주제 객체를 구분할 수 있는 방법이 필요합니다.
위 코드에서는 옵저버 객체의 메서드인 onClick() 메서드에서 주제 객체인 Button 객체를 구분하기 위해 ID 값을 사용하였습니다. ID 값 외에 아래 코드처럼 객체 레퍼런스를 사용할 수도 있을 것입니다.

```java
@Override
public void onClick(View v) { // OnClickListener 메서드
    if (v == loginButton) {
        login(id, password);
    } else if (v == logoutButton) {
        logout();
    }
}
```

앞서 statusChecker 예제나 안드로이드 예제는 모두 주제 객체를 위한 추상 타입을 제공하고 있습니다. 예를 들어, StatusChecker는 상위 타입인 StatusSubject 추상 클래스가 존재하고, 안드로이드의 Button 클래스는 상위 타입인 View가 존재합니다. StatusSubject 클래스와 View 클래스는 모두 옵저버 객체를 관리하기 위한 기능을 제공한다는 공통점이 있습니다.

```java
// StatusChecker 클래스
public void add(StatusObserver observer) { ... }

// view 클래스
public void setOnClickListener(OnClickListener o) { ... }
```
한 주제에 대한 다양한 구현 클래스가 존재한다면, 위 코드처럼 옵저버 객체 관리 및 통지 기능을 제공하는 추상 클래스를 제공함으로써 불필요하게 동일한 코드가 여러 주제 클래스에서 중복되는 것을 방지할 수 있을 것입니다. 하지만 해당 주제 클래스가 한개뿐이라면 옵저버 관리를 위한 추상 클래스를 따로 만들 필요는 없을 것 입니다.

## 옵저버 패턴 구현의 고려 사항
옵저버 패턴을 구현할 때에는 다음 내용을 고려해야 합니다

- 주제 객체의 통지 기능 실행 주체
- 옵저버 인터페이스의 분리
- 통지 시점에서의 주제 객체 상태
- 옵저버 객체의 실행 제약 조건

옵저버 패턴을 구현할 때에 고려할 첫 번째 사항은 옵저버에 통지하는 시점을 결정하는 주체가 누가 되느냐에 대한 것입니다. 앞서 StatusChecker 예에서는 등록된 옵저버에 통지하는 주체가 StatusChecker 클래스였습니다.

```java
public class StatusChecker extends StatusSubject {

    public void check() {
        Status status = loadStatus();

        if (status.isNotNormal()) {
            super.notifyStatus(status); // StatusChecker가 옵저버에 대한 통지 요청
        }
    }
}
```

그런데, 필요에 따라 StatusChecker를 사용하는 코드에서 통지 기능을 수행할 수도 있을것입니다. 예를 들어, 여러 StatusChecker 객체로부터 상태 정보를 읽어와 이들이 모두 비정상인 경우에만 통지를 하고 싶다고 해봅시다.

이 경우 아래 코드에서 보는 것처럼 StatusChecker 객체를 사용하는 코드에서 통지 기능을 실행할 수 있을 것입니다.

```java
StatusChecker checker1 = ...;
StatusChecker checker2 = ...;

checker1.check();
checker2.check();

if (checker1.isLastStatusFault() && checker2.isLastStatusFault()) {
    checker1.notifyStatus();
    checker2.notifyStatus();
}
```

Button처럼 주제 객체의 상태가 바뀔 때마다 옵저버에게 통지를 해 주어야 한다면, 주제 객체에서 직접 통지 기능을 실행하는 것이 구현에 유리합니다. 왜냐면, 주제 객체를 사용하는 코드에서 통지 기능을 실행한다면 상태를 변경하는 모든 코드에서 통지 기능을 함께 호출해 주어야 하는데, 이런 방식은 통지 기능을 호출하지 않는 등 개발자의 실수를 유발할 수 있기 때문입니다.

반대로, 한 개 이상의 주제 객체의 연속적인 상태 변경 이후에 옵저버에게 통지를 해야 한다면, 주제 객체가 아닌 주제 객체의 상태를 변경하는 코드에서 통지 기능을 실행해 주도록 구현하는 것이 통지 시점을 관리하기가 수월합니다.

옵저버 패턴을 구현할 때, 두 번째로 고려할 점은 옵저버의 인터페이스 개수에 대한 것입니다.
예를 들어, GUI 컴포넌트들은 마우스 클릭 이벤트, 터치 이벤트, 드래그 이벤트 등 다양한 이벤트를 제공합니다. 이렇게 한 주제 객체가 통지할 수 있는 상태 변경 내역의 종류가 다양한 경우에는 각 종류 별로 옵저버 인터페이스를 분리해서 구현하는 것이 좋습니다. 모든 종류의 상태 변경을 하나의 옵저버 인터페이스로 처리할 경우, 옵저버 인터페이스는 다음과 같이 거대해 질 것입니다.

```java
public interface EventObserver {
    public void onClick(View v);
    public void onScroll(View v);
    public void onTouch(View v);
    ...
}
```

위 코드처럼 모든 종류의 상태 변화를 수신하는 옵저버 인터페이스가 존재할 경우, 콘크리트 옵저버 클래스는 모든 메서드를 구현해 주어야 합니다. 실제로 콘크리트 옵저버 클래스에서 구현할(관심 있는) 메서드가 onClick()뿐이라 하더라도 아래 코드처럼 나머지 메서드의 구현을 만들어 주어야 합니다.(즉, 불필요한 코드를 만들어야 합니다.)

```java
public class OnlyClickObserver implements EventObserver {

    public void onClick(View v) {
        ...// 이벤트 처리 코드
    }

    public void onScroll(View view) { /* 빈 구현 */}
    public void onTouch(View view) { /* 빈 구현 */}
    ... // 다른 메서드의 빈 구현
}
```

주제 객체 입장에서도 각 상태마다 변경의 이유가 다르기 때문에, 이들을 한 개의 옵저버 인터페이스로 관리하는 것은 향후에 변경을 어렵게 만드는 요인이 될 수 있습니다. 옵저버 타입이 한 개일 경우, 클릭, 스크롤, 터치 이벤트를 통지하는 코드가 서로 강하게 연결될 가능성이 높아지는데, 이 경우 옵저버 목록을 관리하고 옵저버 이벤트를 통지하는 코드의 복잡도가 증가하게 되며, 이는 곧 기존 이벤트를 제거하거나 새로운 종류의 이벤트 추가를 어렵게 만드는 원인이 될 수 있습니다.

옵저버 패턴을 구현할 때 주의해야 할 세 번째 사항은 통지 시점에서 주제 객체의 상태에 결함이 없어야 한다는 것입니다.

예를 들어, 한 주제 클래스의 코드를 아래와 같이 구현했다고 합시다.

```java
public class AnySubject extends SomeSubject {

    @Override
    public void changeState(int newValue) {
        // 아래 코드가 실행되기 전에 옵저버가 상태를 조회
        if (isStateSome()) {
            state += newValue;
        }
    }
}
```

이 코드에서 changeState() 메서드는 상위 클래스에 정의된 changeState() 메서드를 호출합니다. 그런데, 상위 타입의 changeState() 메서드에서 옵저버에 통지를 하게 되면 어떻게 될까요? 이 경우 super.changeState() 이후의 코드를 실행하기 전에 옵저버 객체가 AnySubject의 상태 값을 조회하게 됩니다. 그런데 AnySubject 클래스는 super.changeState() 코드를 실행한 이후에 다시 상태를 변경하게 되므로, 결과적으로 옵저버 객체는 완전하지 못한 상태 값을 조회하게 되는 것입니다.

옵저버 객체가 올바르지 않는 상태 값을 사용하게 되는 문제가 발생하지 않도록 만드는 방법 중의 하나는 상태 변경과 통지 기능에 템플릿 메서드 패턴을 적용하는 것입니다. 아래 코드는 템플릿 메서드 패턴을 적용한 예를 보여주고 있습니다.

```java
// 상위 클래스
public class SomeSubject {

    // 템플릿 메서드로 구현
    public void changeState(int newState) {
        internalChangeState(newState);
        notifyObserver();
    }

    protected void internalChangeState(int newState) {
        ...
    }
}


// 하위 클래스
public class AnySubject extends SomeSubject {
    // internalChangeState() 메서드 실행 이후에, 옵저버에 통지
    @Override
    public void internalChangeState(int newValue) {
        super.internalChangeState(newValue);
        if(isStateSome()) {
            state += newValue;
        }
    }
}
```

위 코드에서 상위 클래스의 changeState() 메서드는 internalChangeState() 메서드를 호출한 뒤에 notifyObserver() 메서드를 호출해서 옵저버에게 상태 변화를 통지하고 있습니다.
따라서 AnySubject 클래스의 internalChangeState() 메서드에서 상태 변화를 마무리한 다음에 옵저버 객체가 상태 값을 접근하게 되므로, 옵저버는 완전한  상태 값을 사용할 수 있게 됩니다.

옵저버 패턴을 구현할 때 마지막으로 주의해야할 사항은 옵저버 객체의 실행에 대한 제약 규칙을 정해야 한다는 것입니다.

예를 들어, 주제 객체가 옵저버에 통지하기 위해 사용되는 메서드를 아래와 가팅 구현했다고 합시다.

```java
public void notifyToObserver() {
    for(StatusObserver o: observers) {
        o.onStatusChange();
    }
}

public void changeState(int newState) {
    internalChangeState(newState);
    notifyToObserver();
}
```

만약 10개의 옵저버 객체가 있고, 각 옵저버 객체의 onStatusChange() 메서드마다 실행 시간이 십 분 이상 걸린다면 어떻게 될까요? 이 경우, changeState() 메서드를 호출한 코드는 모든 옵저버 객체의 onStatusChange() 메서드 실행이 종료될 때까지 100분이 이상 기다려야 한다. 또는 한 개의 옵저버로 인해 다른 옵저버의 실행이 지연되는 상황이 발생할 수도 있다.

따라서 옵저버 인터페이스를 정의할 때에는 옵저버 메서드의 실행 제한에 대한 명확한 기준이 필요합니다. 예를 들어,StatusObserver.onStatusChange() 메서드는 수 초 이내에 응답해야 하고 긴 작업을 수행해야 할 경우 별도 쓰레드로 실행해야 한다는 등의 제약 조건이 필요합니다. 안드로이드의 경우 사용자 이벤트에 대해 5초 이상 프로그램이 응답하지 않으면, ANR 대화 상자를 띄어 프로그램 종료 여부를 확인하는데, 이는 사용자 이벤트를 처리하는 코드는 5초 이내에 응답을 처리해야 한다는 기준을 제시하고 있는 것입니다.

이외에 생각해 볼만한 고려사항들이 있습니다. 예를 들어, 옵저버 객체에서 주제 객체의 상태를 다시 변경하면 어떻게 구현할 것인가에 대한 문제나 옵저버 자체를 비동기로 실행하는 문제 등을 생각해 볼 수 있습니다. 이런 문제 주어진 상황에 따라 대답이 달라질 수 있으므로, 실제 옵저버 패턴을 적용할 때 한 번 고민해 보기 바랍니다.



## 미디에이터(Mediator) 패턴
비디오 플레이어를 만든다고 해봅시다. 비디오 플레이어 프로그램은 상단에 제목, 중앙에는 영상 플레이어, 우측은 영상 목록, 하단에는 제어 영역으로 구성되어 있다고 합시다.

이 비디오 플레이어의 주요 기능은 아래와 같습니다.

- 동영상 목록에서 특정 제목을 클릭하면, 제목에 해당하는 동영상이 플레이 영역에 표시되고, 제목 표시 영역에 해당 제목을 표시합니다.

- 영상 제어 영역에서 재생/멈춤 버튼을 누르면 영상 플레이 영역은 영상을 재생하거나 멈추고, 시간 이동 조작을 하던 영상 플레이 영역은 알맞은 시점으로 이동해서 영상을 재생합니다.

- 영상 제어 영역에서 다음/이전 버튼을 영상 목록에서 다음이나 이전 영상을 재생합니다.

- 영상 플레이 화면을 터치하면 플레이가 멈추고 다시 터치하면 재생됩니다. 이때 영상 제어 부분의 UI도 중지/시작 모양으로 알맞게 변경됩니다.

위 기능을 제공하는 플레이어를 만들기 위해 각 영역은 별도 클래스로 구현한다면, 각 클래스는 아래 그림과 같은 의존을 갖게 될 것입니다.


![Untitled Diagram (1)](https://user-images.githubusercontent.com/22395934/81063005-012b0000-8f12-11ea-878b-753a733d045b.png)

위 그림의 구조는 책임 별로 알맞게 클래스가 분리되었지만, 몇 가지 단점이 있습니다. 첫 번째 단점은 재사용이 어렵다는 것입니다.

예를 들어, 비디오가 아닌 MP3를 위한 플레이어에서 MediaController를 재사용하고 싶다고 가정해 보겠습니다. MediaController는 MP3 플레이어를 위한 제어 기능(재생/멈춤/시간 이동/다음 곡/이전 곡)을 제공하고 있지만, MedialController를 재사용하려면 MP3 플레이와 상관없는 VidioPlayer 클래스와 VidioListUI 클래스가 필요합니다. 비슷하게 동영상 재생 기능을 위해 VidioPlayer 클래스만 재사용하고 싶은 경우에도 MedialController 클래스를 필요로 합니다. 불필요한 클래스를 제거하고 싶다면, 소스 코드 수준에서 필요한 코드만 추려 내야만 합니다.

또 다른 단점은 함께 사용되는 클래스가 증가할수록 개별 클래스의 수정이 어려워진다는 점입니다. 예를 들어, 다음과 같은 요구사항이 새롭게 추가되었다고 합시다.

- 플레이 화면 좌측에 시스템이 추천한 영상 목록을 표시
- 영상 자막 존재 시, 자막 표시

이 요구 사항을 충족하기 위해 클래스 구조는 아래 그림처럼 바귈 것입니다. 이제 VidioPlayer 클래스의 변경은 너무 많은 클래스에 영향을 주게 됩니다. 심지어 CaptionUI의 변경이 VidioPlayer에 영향을 주고 이로 인해 다른 클래스가 변경될 수도 있습니다.


![Untitled Diagram](https://user-images.githubusercontent.com/22395934/81063928-ae524800-8f13-11ea-8f34-cfb525bd967b.png)

책임에 따라 알맞은 객체를 분리함으로써 객체의 재사용을 높일 수 있을거라 기대했지만, 위 그림은 역할에 맞게 객체를 분리했음에도 불구하고 오히려 전체 클래스가 하나의 단일 구조가 되어 변경이나 재사용이 어렵게 되는 상황이 발생하였습니다.

이런 문제가 발생한 이유는 객체 간의 의존이 직접 연결되어 있기 때문입니다. 클래스 다이어그램을 살펴보면 VidioPlayer 객체는 여러 객체와 통신하는 규칙이 잘 정해져 있지만, 이들 객체들에 대한 직접적인 의존을 갖고 있습니다.

예를 들어, MediaController 클래스의 시간 이동 관련 코드는 VidioPlayer 클래스의 메서드를 직접 실행하고, VidioPlayer 클래스는 다시 CaptionUI 클래스의 메서드를 직접 실행합니다. 이렇게 객체 간의 메시지 흐름을 각 클래스에 직접적인 의존으로 구현하게 되면, 개별 클래스의 재사용이 어려워지고 메시지 흐름을 변경하려면 관련된 클래스들을 모두 변경해 주어야 하는 문제가 발생하게 됩니다.

미디에이터(Mediator) 패턴을 사용하면 이런 문제를 해소할 수 있습니다. 미디에이터 패턴은 각 객체들이 직접 메시지를 주고받는 대신, 중간에 중계 역할을 수행하는 미디에이터 객체를 두고 미디에이터를 통해서 각 객체들이 간접적으로 메시지를 주고 받도록 합니다. 앞서 비디오 플레이어에 미디에이터 패턴을 적용하면 아래 그림과 같은 구조를 갖게 됩니다.

![Untitled Diagram (2)](https://user-images.githubusercontent.com/22395934/81065536-a0ea8d00-8f16-11ea-91f3-ebbfdb22a2d6.png)

위 그림에서 중간에 위치한 VidioMeiator 클래스가 미디에이터 역할을 하며, 나머지 VidioPlayer, MediaController, VidioListUIM TitleUI는 협업 대상 역할을 수행합니다. 이들 협업 대상 객체들은 서로 직접적인 의존을 맺기보다는, 미디에이터 객체를 통해서 간접적으로 연결됩니다.

예를 들어, VidioListUI 클래스는 VidioPlayer 클래스에 직접적으로 의존하지 않는 대신, VidioMediator 클래스에 대한 의존만 갖고 있습니다. VidioListUI 객체는 목록에서 특정 비디오가 선택되면, VidioListUI 객체는 아래 리스트처럼 VidioMediator 객체의 메서드를 호출합니다.

```java
//VidioListUI
private VideoMediator videoMediator;

public void onSelectedItem(int selectedIdx) {

    VideoInfo videoInfo = videoList.get(selectedIdx);
    videoMediator.selectVideo(videoInfo.getFile());
}
```

VideoListUI 객체로부터 재생할 비디오 정보를 받은 VideoMediator 객체는 아래 코드처럼 그 정보를 VidioPlayer 객체에 전달해서 영상을 재생하도록 하고 TitleUI 객체에 전달해서 제목을 변경하도록 합니다.

```java
// VideoMediator
private VideoPlayer videoPlayer
private TitleUI titleUI;

public void selectVideo(File videoFile) {
    // 미디에이터는 다른 협업 객체에게 요청을 전달합니다.
    videoPlayer.play(videoFile);
    titleUI.setTitle(videoFile);
}
```

비슷하게 다른 협업 객체들도 모든 요청을 미디에이터에 보내며, 미디에터는 그 요청을 처리에 알맞은 객체를 실행합니다. 이렇게 각 협업 객체가 서로 알 필요 없이 미디에이터가 각 객체 간의 메시지 흐름을 제어하기 때문에, 새로운 협업 객체가 추가되더라도 기존 클래스를 수정할 필요 없이 미디에이터 클래스만 수정해 주면 됩니다. 물론 메시지 흐름이 변경되더라도 메시지 흐름을 실제로 제어하는 건 미디에이터이므로 미디에이터만 수정될 뿐 각 협업 클래스를 수정할 필요는 없으며 수정하더라도 변경 범위가 최소화 됩니다.

미디에이터 패턴은 각 협업 클래스에 흩어져 있는 흐름 제어를 미디에이터로 모으기 때문에, 각 협업 클래스의 코드는 단순해 집니다. 각 협업 클래스는 미디에이터에만 의존하거나 또는 미디에이터나 다른 협업 클래스에 의존하지 않기 때문에, 개별 협업 클래스를 수정하거나 확장하거나 재사용하기 쉬워집니다. 또한 미디에이터에 각 협업 객체의 흐름 제어 코드가 모여 있기 때문에 전체 협업 객체 간의 메시지 흐름을 이해하고 수정하고 확장하는 것을 상대적으로 쉽게 만들어 줍니다.

반면에, 미디에이터 패턴을 사용할 때의 단점은 협업 클래스의 개수가 증가할수록 미디에이터의 코드는 복잡해지기 때문에, 미디에이터 자체를 유지 보수하는 것은 협업 클래스에 비해 어려워진다는 것입니다.

## 추상 미디에이터 클래스의 재사용
미디에이터 패턴을 적용할 때 협업 객체 간의 동일한 메시지 흐름이 서로 다른 기능에서 반복해서 사용될 경우, 미디에이터 추상 클래스를 사용함으로써 미디에이터 자체의 재사용을 높일 수 있습니다.

예를 들어, MP3 플레이어와 비디오 플레이어는 협업 객체의 구성이 미디어 제어기, 플레이 목록, 제목 표시로 비슷합니다. 이 경우, 상위의 추상 미디에이터 클래스를 만들고, 비디오 플레이어와 MP3 플레이어를 위한 하위 미디에이터를 만들어서 객체 간의 협업 흐름을 재사용할 수 있게 됩니다.

PlayMediator는 추상 클래스로서 MediaController, ListUI, TitleUI 객체들 간의 메시지 흐름을 제어하는 역할을 수행합니다. PlayerMediator 클래스에서 주의해서 살펴볼 부분은 아래 코드에서 보여준 것처럼 select() 메서드는 구현을 제공하는 반면에 volumeChanged() 메서드는 추상 메서드라는 점입니다.

```java
public abstract class PlayerMediator implements ControllerObserver {
    private MediaController mediaController;
    private TitleUI titleUI;

    public PlayerMediator() {
        this.mediaController = new MediaController();
        this.mediaController.addObserver(this);
        this.titleUI = new TitleUI();
        ...
    }

    public void select(File file) {
        titleUI.setTitle(file);
    }

    ...
    // volumeChanged의 구현은 제공하지 않음
    // MediaController 객체의 볼륨 조절 이벤트 발생시
    // volumeChanged() 메서드 호출

}
```

select() 메서드는 협업 객체 간의 흐름 제어를 제공하므로 하위 클래스에서는 select() 메서드를 재사용해서 기능을 확장합니다. 반면 volumeChanged() 메서드는 추상 메서드이므로 흐름 제어를 재사용해서 기능을 확장합니다. 반면 volumeChanged() 메서드는 추상 메서드이므로 흐름 제어를 재사용하기보다는 하위 클래스에서 알맞게 기능을 구현합니다. 예를 들어, 동영상 플레이 기능을 구현해야 할 경우, PlayerMediator 추상 클래스를 상속받은 VideoPlayerMediator 클래스를 아래 코드처럼 만들 수 있을 것입니다.

```java
//PlayerMediator 클래스를 재사용하면서 필요한 기능 확장
public class VideoPlayerMediator extends PlayerMediator {

    private VideoPlayer videoPlayer;

    public VideoPlayerMediator() {
        super();
        this.videoPlayer = new VideoPlayer();
    }

    @Override
    public void select(File file) {
        videoPlayer.play(file);
        super.select(file); // 상위 미디에이터에 정의된 협업 기능 재사용
    }

    // 하위 미디에이터에서 새로운 협업 기능 구현
    public void volumeChanged(int volume) {
        videoPlayer.changeVolume(volume);
    }
}
```

VideoPlayerMediator 클래스는 PlayerMediator 클래스가 제공하는 객체 연동 부분을 재사용하면서 (select() 메서드 재정의 부분) 동시에 비디오 플레이를 위한 객체와의 협업 기능을 추가하고 있습니다. 즉, VideoPlayerMediator는 PlayerMediator 클래스에 정의된 ListUI, MediaController,  TitleUI 객체 간의 메시지 흐름을 재사용하면서, 비디오 관련 기능을 확장하고 있는 것입니다.

## 파사드(Facade) 패턴

직원 정보, 직원의 이력 정보, 그리고 직원에 대한 평가 정보를 읽어 와 화면에 보여주는 GUI 프로그램을 만들면 아래 그림과 같이 데이터를화면에 출력해 주는 GUIViewer 클래스는 각 데이터를 제공하는 Dao 객체에 직접 접근하는 구조를 갖게 될 것입니다.

![Untitled Diagram (3)](https://user-images.githubusercontent.com/22395934/81474854-102bee00-9243-11ea-92bd-2d96277a0a09.png)


HR팀으로부터 화면뿐만 아니라 XML이나 엑셀로 동일한 데이터를 추출해 달라는 요구 사항이 들어왔습니다.
이를 구현하기 위해 아래 그림과 같이 XMLExporter 클래스와 ExcelExporter 클래스를 구현하였습니다.

![Untitled Diagram](https://user-images.githubusercontent.com/22395934/81474957-e58e6500-9243-11ea-8520-1953558b4387.png)

위 그림의 구조에서 발생할 수 있는 문제점 중 가장 큰 것은 GUIViewer, XMLExporter, ExcelExporter 사이에서 코드 중복이 발생한다는 점입니다. 세 클래스는 모두 동일한 코드를 이용해서 EmpDao, ResumeDao, EvaluationDao 객체를 사용하고 데이터를 추출합니다.
이런 코드 중복에서 더 큰 문제는 완전히 똑같기 보다는 GUIViewer, XMLExporter, ExcellExporter 마다 약간씩 달라질 수 있다는 점입니다. 중복된 코드에서 미세한 차이가 발생하면 이후 변경해 주어야 할 때 미세한 차이점을 누락할 가능성이 높아지고, 이는 결극 프로그램에 버그를 만드는 원인이 됩니다.

또 다른 문제는 EmpDao, ResumeDao, EvaluationDao에 대해 직접적인 의존을 하고 있다는 점입니다. 필요한 건 이 세개의 Dao가 제공하는 데이터를 통합한 하나의 데이터인데, 이 데이터를 얻기 위해 개별 Dao 객체에 의존하고 있습니다. 따라서 이들 Dao들의 인터페이스에 일부 변화가 발생하면 이 Dao를 직접적으로 사용하고 있는 나머지 GUIViewer, XMLExporter, ExcelExporter에 모두 영향을 미치게 됩니다.

앞서 언급한 두개의 문제인 코드 중복과 직접적인 의존을 해결하는데 도움을 주는 패턴이 파사드(facade) 패턴입니다. `파사드 패턴은 서브 시스템을 감춰 주는 상위 수준의 인터페이스를 제공함으로써 이 문제를 해결합니다.` 앞서 예제에 파사드 패턴을 적용하면 구조는 아래 그림처럼 바뀝니다.

![Untitled Diagram (1)](https://user-images.githubusercontent.com/22395934/81475221-cf81a400-9245-11ea-93ce-b2f0e96852b2.png)

그림에서 EmpReportDaoFacade는 서브 시스템에 속한 각 Dao를 이용해서 클라이언트가 원하는 데이터를 제공하기 위한 인터페이스를 제공하고 있으며, 파사드 패턴에서 파사드의 역할을 맡습니다.

각 클라이언트는 이제 파사드를 이용해서 원하는 기능을 수행하게 됩니다. 파사드 패턴 적용전에는 각 클라이언트가 직접 서브 시스템에 접근했다면, 파사드 패턴 적용 후에는 아래 그림과 같이 파사드를 통해서 간접적으로 서브 시스템에 접근합니다.


#### 파사드 패턴 적용 전

```java 
public class GuiViewer {
  
    public void display() {
        ...
        Emp emp = empDao.select(id);
        ...
        Resume resume = resumeDao.select(id);
        ...
        Evaluation eval = evaluationDao.select(id);
        ...
    }      
}

public class ExcelExporter {
 
  public void display() {
        ...
        Emp emp = empDao.select(id);
        ...
        Resume resume = resumeDao.select(id);
        ...
        Evaluation eval = evaluationDao.select(id);
        ...
    }    
}
```

#### 파사드 패턴 적용 후

```java 
public class GuiViewer {
 
  public void display() {
        ...
        EmpReport rep = empReportDaoFacade.select(id); 
        ...
    }    
}

public class ExcelExporter {
  
   public void display() {
       ...
        EmpReport rep = empReportDaoFacade.select(id); 
        ...
    }    
}
```

위 코드를 보면 파사드 패턴을 적용함으로써 클라이언트 코드가 간결해지는 것을 알 수 있습니다. 클라이언트의 코드가 간결해지는 것 보다 더 큰 이득은 클라이언트와 서브 시스템 간의 직접적인 의존을 제거했다는 점입니다. 파사드 패턴을 적용하면 클라이언트는 파사드에만 의존하기 때문에, 서브 시스템의 일부가 변경되더라도 그 여파는 파사드로 한정될 가능성이 높습니다.

예를 들어, 파사드 패턴 적용 후 코드를 보면 EmpDao의 일부가 변경되더라도 그 변경의 여파는 EmpReportDaoFacade에만 영향을 주게 됩니다. 반면에 좌측에서 파사드 패턴 적용 전 코드에서는 EmpDao가 변경되면 GuiViewer와 ExcelExporter가 함께 영향을 받게됩니다. 이는 서브 시스템의 변경을 더 어렵게 만들게 됩니다.

## 파사드 패턴의 장점과 특징
클라이언트와 서브 시스템 간의 결합을 제거함으로써 얻을 수 있는 또 다른 이점은 파사드를 인터페이스로 정의함으로써 클라이언트의 변경 없이 서브 시스템 자체를 변경할 수 있다는 것입니다.

앞서 예제에서 Dao가 아닌 HTTP를 이용해서 데이터를 읽어 오도록 서브 시스템을 교체하더라도 아래 그림처럼 클라이언트의 영향 없이 알맞은 콘크리트 파사드 클래스를 구현해 주기만 하면 됩니다.

![Untitled Diagram (2)](https://user-images.githubusercontent.com/22395934/81475771-3bb1d700-9249-11ea-87e9-b18e62ae2097.png)

파사드 패턴을 적용한다고 해서 서브 시스템에 대한 직접적인 접근을 막는 것은 아닙니다. 파사드 패턴은 단지 여러 클라이언트에 중복된 서브 시스템 사용을 파사드로 추상화할 뿐입니다.
따라서 다수의 클라이언트에 공통된 기능은 파사드를 통해서 쉽게 서브 시스템을 사용할 수 있도록 하고, 보다 세밀한 제어가 필요한 경우에는 서브 시스템에 직접 접근하는 방식을 선택할 수 있습니다.

> 파사드 패턴을 클래스와 비교해보면, 파사드는 마치 서브 시스템의 상세함을 감춰 주는 인터페이스와 유사합니다. 파사드를 통해서 서브 시스템의 상세한 구현을 캡슐화하고, 이를 통해 상세한 구현이 변경되더라도 파사드를 사용하는 코드에 주는 영향을 줄일 수 있게 됩니다.



## 추상 팩토리(Abstract Factory) 패턴

비행기를 조정하고 미사일을 발사해서 적을 미사일로 쏴 맞춰 잡는 슈팅 게임을 만든다고 가정해봅시다. 이런 게임은 흔히 여러 종유릐 적이 출현하고 한 단계의 끝에 다다르면 그 단계의 보스가 출현하고, 이 보스를 맞춰 잡으면 당므 단계로 넘어가는 방식을 취합니다. 또한, 중간 중간에 공격은 하지 않지만, 부딪히면 안 되는 장애물이 출현하기도 합니다. 보스 적기, 작은 적기 그리고 장애물은 단계마다 다른 종류가 출현합니다.

예를 들어, 특별 공격으로 작은 분신을 만들어 내는 보스와 강력한 미사일을 발사하는 보스의 두 가지 종류가 있을 수 있고, 적기에도 미사일을 발사하는 적기와 자폭하는 적기가 있을 수 있습니다. 또한, 각 단계마다 적들의 공격력이나 방어력이 달라질 수 있습니다. 이런 보스, 적기, 장애물을 구현하기 위해 아래 그림과 같이 Boss, SmallFlight, Obstacle 클래스 및 하위 클래스를 구성하였습니다.

![Untitled Diagram (4)](https://user-images.githubusercontent.com/22395934/81499868-70856300-9309-11ea-8648-9c4200544fec.png)

실제 게임 플레이를 진행하는 Stage 클래스는 몇 단계인지 따라 서로 다른 적기, 장애물 또는 보스를 생성해야 합니다. 이를 처리하기 위해 Stage 클래스의 코드를 다음과 같이 작성할 수 있을 것입니다.

```java
// Stage 클래스
public void createEnemies() {

    for (int i = 0; i<= ENEMY_COUNT; i++) {
        if(stageLevel == 1) {
            enemies[i] = new DashSmallFlight(1, 1); // 공격/수비력 1
        } else if (stageLevel == 2) {
            enemies[i] = new MissileSmallFlight(1, 1);
        }
    }

    if (stageLevel == 1) {
        boss = new StrongAttackBoss(1, 10);
    } else if (stageLevel == 2) {
        boss = new CloningBoss(5, 20);
    }
}

private void createObstacle() {
    for(int i = 0; i < OBSTACLE_COUNT; i++) {
        if (stageLevel == 1) {
            obstacles[i] = new RockObstacle();
        } else {
            obstacles[i] = new BombObstacle();
        }
    }
}
```

위 코드의 문제는 단계별로 적기, 보스, 장애물을 생성하는 규칙이 Stage 클래스에 포함되어 있다는 점입니다. 새로운 적 클래스가 추가되거나 각 단계의 보스 종류가 바뀔 때 Stage 클래스를 함께 수정해 주어야 하고, 각 단계별로 적기 생성 규칙이 달라질 경우에도 Stage 클래스를 수정해 주어야 합니다.
또한 중첩되거나 연속된 조건문으로 인해 코드가 복잡해지기 쉽고 이는 코드 수정을 어렵게 만드는 원인이 됩니다.

적과 장애물 객체의 생성을 Stage 클래스에서 직접 수행하면서 앞서 언급한 문제들이 발생하기 때문에, Stage 클래스로부터 객체 생성 책임을 분리함으로써 이 문제를 해소할 수 있습니다. 이 때 사용되는 패턴이 바로 `추상 팩토리 패턴입니다.`

추상 팩토리 패턴에서는 관련된 객체 군을 생성하는 책임을 갖는 타입을 별도로 분리합니다. 앞서 예의 경우 SmallFlight, Boss, Obstacle 객체를 생성해 주는 책임을 갖는 EnemyFactory 타입을 추가할 수 있습니다.

EnemyFactory 클래스는 Boss, SmallFlight, Obstacle 객체를 생성해 주는 메서드를 정의하고 있습니다. 여기서 EnemyFactory 클래스는 객체 생성 메서드를 선언하는 추상 타입으로서 팩토리에 해당되며, 팩토리가 생성하는 대상인 Boss, SmallFlight, Obstacle은 제품 타입이 됩니다.

EnemyFactory.getFactory() 메서드는 정적 메서드로서 파라미터로 전달받은 레벨에 따라 알맞은 EnemyFactory 객체를 리턴하도록 정의하였습니다. 아래 코드를 보고 어떻게 생성하는지 살펴보겠습니다.

```java
public abstract class EnemyFactory {
    public static EnemyFactory getFactory(int level) {
        if (level == 1) 
            return EasyStageEnemyFactory();
        else 
            return HardEnemyFactory();
    }

    // 객체 생성을 위한 팩토리 메서드
    public abstract Boss createBoss();
    public abstract SmallFlight createSmallFlight();
    public abstract Obstacle createObstacle();
}
```

팩토리인 EnemyFactory를 구현한 콘크리트 팩토리 클래스는 아래 코드에서 보듯이 알맞은 객체를 생성합니다.


```java
public abstract class EnemyFactory {
    public static EnemyFactory getFactory(int level) {
        if (level == 1) {
            // 적 생성 규칙 변경 시, 새로운 팩토리 클래스를 만들면 됩니다.
            return SomethingNewEnemyFactory();
        else {
            return HardEnemyFactory();
        }
    }
```

위 코드에서 EnemyFactory 객체를 구하는 기능을 EnemyFactory 클래스에 정의했는데, DI를 사용해도 됩니다. DI를 사용하면 아래 코드처럼 생성자나 설정 메서드를 통해서 EnemyFactory 객체를 전달받게 되므로, EnemyFactory 클래스에 getFactory() 메서드를 정의할 필요가 없어집니다. 따라서 EnemyFactory 추상 클래스를 인터페이스로 전환할 수 있게 됩니다.

```java
public class Stage {

    private EnemyFactory enemyFactory;

    //DI를 적용하면 팩토리를 구하는 기능을 EnemyFactory에 구현할 필요가 없습니다.
    public Stage(int level, EnemyFactory enemyFacotry) {
        this.level = level;
        this.enemyFactory = enemyFactory;
    }
    ...
}
```

만약 팩토리가 생성하는 객체가 늘 동일한 상태를 갖는다면, 프로토타입 방식으로 팩토리를 구현할 수 있습니다. 프로토타입 방식은 아래 코드처럼 생성할 객체의 원형 객체를 등록하고, 객체 생성 요청이 있으면 원형 객체를 복제해서 생성합니다.

```java
// 프로토타입 방식의 팩토리
public class Factory {

    private ProductA productAProto;
    private ProductA productAProto;

    public Factory(ProductA productAProto, ProductB productBProto) {
        this.productAProto = productAProto;
        this.productBProto = productBProto;
    }

    public ProductA createA() {
        return (ProductA) ProductAProto.clone();
    }

    public ProductB createB() {
        return (ProductB) ProductBProto.clone();
    }

}
```

프로토 타입 방식의 팩토리를 사용하면, 객체 군 마다 팩토리 클래스를 작성할 필요 없이 객체 군 마다 팩토리 객체를 생성해 주면 됩니다.

```java
// 객체 군 1을 위한 팩토리 객체
Factory family1Factory = new Factory(new HighProductA(), new HighProductB());
ProductA a = family1Factory.createA(); // HighProductA 객체 복제본 생성

// 객체 군 2를 위한 팩토리 객체
Factory family2Factory = new Factory(new LowProductA(), new LowProductB());
ProductB b = family2Factory.createB(); // LowProductB 객체 복제본 생성
```

## 컴포지트(Composite) 패턴

빌딩의 장비들의 전원을 관리하는 제어 프로그램을 개발한다고 합시다. 이 프로그램을 만들기 위해 개별 장비의 전원을 켜고 끄는 기능을 제공하는 인터페이스를 정의하고, 장비 별로 알맞은 콘크리트 클래스를 구현했습니다. 또한, 개별 장비가 아닌 장비들을 하나로 묶어서 관리할 수 있도록 하기 위해 아래 그림처럼 
DeviceGroup 클래스를 추가하였습니다.

![Untitled Diagram (1)](https://user-images.githubusercontent.com/22395934/82339718-4fb7be80-9a29-11ea-84c8-eac272071ee0.png)

위 타입을 이용해서 장비들의 전원을 제어하는 코드는 다음과 같이 Device 타입과 DeviceList 타입을 구분해서 처리할 것입니다.

```java
public class PowerController {

    public void turnOn(Long deviceId) {
        Device device = findDeviceById(Long deviceId);
        device.turnOn();
    }
    // turnGroupOn()과 turnOn()은 개별/그룹 차이를 빼면 동일한 기능입니다.
    public void turnGroupOn(Long groupId) {
        DeviceGroup group = findGroupById(Long groupId);
        group.turnAllOn();
    }
}
```

위 코드의 단점은 PowerController 입장에서 봤을 때 장비나 장비 그룹의 전원을 켜는 동작은 동일한 동작임에도 불구하고 Device와 DeviceGroup을 구분해서 처리해야 한다는 점입니다. 전원 켜고/끄는 기능 외에 소비 전력 측정과 같은 새로운 기능이 추가될 경우 PowerController 클래스에는 turnOn()/turnGroupOn()처럼 거의 동일한 메서드가 추가 됩니다.

거의 동일한 코드가 중복된다는 점은 결국 복잡도를 높여서 코드의 수정이나 확장을 어렵게 만드는데, 이런 단점을 해소하기 위해 사용되는 패턴이 컴포지트(Composite) 패턴입니다. 컴포지트 패턴은 이 문제를 전체-부분을 구성하는 클래스가 동일 인터페이스를 구현하도록 만듬으로써 해결합니다.


![Untitled Diagram](https://user-images.githubusercontent.com/22395934/82339961-9d342b80-9a29-11ea-9039-be3041986086.png)

위의 그림은 컴포지트 패턴을 적용한 결과를 보여주고 있습니다.
여기서 DeviceGroup 클래스는 개별 Device를 하나의 그룹으로 묶어주는데, Aircon 클래스나 Light 클래스처럼 DeviceGroup 클래스도 Device 인터페이스를 상속받는 것을 알 수 있습니다. 즉, 부분(Aircon, Light등)과 전체(즉, DeviceGroup)를 한 개의 인터페이스로 추상화 한 것입니다.

- 컴포넌트 그룹을 관리합니다.
- 컴포지트에 기능 실행을 요청하면, 컴포지트는 포함하고 있는 컴포넌트들에게 기능 실행 요청을 위임합니다.

위 그림에서 DeviceGroup 클래스가 컴포지트에 해당하며 아래처럼 두 개의 책임을 구현할 수 있습니다.

```java
public class DeviceGroup implements Device {
    private List<Device> devices = new ArrayList<Device>)();

    public void addDevice(Device d) {
        devices.add(d);
    }

    public void removeDevice(Device d) {
        devices.remove(d);
    }

    public void turnOn() {
        for (Device device: devices) {
            device.turnOn(); // 관리하는 Device 객체들에게 실행 위임
        }
    }

    public void turnOff() {
        for (Device device: devices) {
            device.turnOff() // 관리하는 Device 객체들에게 실행 위임
        }
    }
}
```

위 코드에서 addDevice() 메서드와 removeDevice() 메서드는 DeviceGroup이 관리할 Device 객체들의 목록을 관리합니다. turnOn() 메서드와 turnOff() 메서드는 DeviceGroup이 관리하고 있는 Device 객체들에게 기능 실행을 위임합니다. 이는, 아래 코드처럼 DeviceGroup 객체에 Device  객체를 등록한 뒤에 DeviceGroup 객체의 turnOn() 메서드를 호출하면, 등록되어 있는 모든 Device 객체의 turnOn() 메서드가 호출된다는 것을 뜻합니다.

```java
Device device1 = ...;
Device device2 = ...;
DeviceGroup group = new DeviceGroup();
group.addDevice(device1);
group.addDevice(device2);

group.turnOn(); // device1과 device2의 turnOn() 실행
```



## 컴포지트 패턴 구현의 고려 사항
컴포지트 패턴을 구현할 때 고려할 점은 컴포넌트를 관리하는 인터페이스를 어디서 구현할지에 대한 여부입니다. 컴포지트 패턴의 장점 중 하나는 클라이언트가 컴포지트와 컴포넌트를 구분하지 않고 컴포넌트 인터페이스만으로 프로그래밍 할 수 있게 돕는다는 점인데, 앞서 예제에서는 컴포지트인 DeviceGroup에 인터페이스를 정의했습니다.따라서 Device 그룹을 만들어야 하는 코드는 DeviceGroup 타입에 직접 접근해야 하는 상황이 발생합니다.

Device 타입에 컴포넌트를 관리하는 인터페이스를 추가하면, 클라이언트 입장에서 DeviceGroup 타입을 사용하지 않고도 그룹을 생성할 수 있게 됩니다. 예를 들어, 다음과 같이 Device 타입만 사용하는 것이 가능해집니다.(DeviceGroup 객체 자체를 생성하는 코드에서만 DeviceGroup 타입을 사용하게 됩니다.)

```java
public void addDeviceTo(Device device, Integer toDeviceId) {
    Device composite = findDevice(toDeviceId);
    composite.addDevice(device);
}
```

Device 타입에 컴포넌트를 관리하는 addDevice() 메서드와 removeDevice() 메서드가 정의되어 있을 경우, Light 클래스나 Aircon 클래스처럼 컴포지트가 아닌 클래스에서 이 두 기능이 정상적으로 동작하면 안됩니다. 예를 들어, Light 객체에 addDevice() 메서드를 이용해서 다른 객체를 추가하는 것은 논리적으로 말이 안됩니다. 이런 상황이 발생하지 않도록 하기 위해 Device 타입에 이들 기능에 익셉션을 발생시키는 기본 구현을 추가하고, DeviceGroup 클래스에서 알맞게 재정의하도록 구현할 수 있을 것입니다.

```java
// Device에 addDevice()와 removeDevice()에 대한 기본 기능 구현
public abstract class Device {
    public void addDevice(Device d) {
        throw new CanNotAddException("추가 할 수 없음");
    }
    
    public void removeDevice(Device d) {
        // 아무 것도 하지 않음
    }

    public abstract void turnOn();
    public abstract void turnOff();
}
```


```java
// GroupDevice에서 알맞게 재정의
public class GroupDevice extends Device {
    @Override
    public void addDevice(Device d) {
        device.add(d);
    }

    @Override
    public void removeDevice(Device d) {
        devices.remove(d);
    }
    ...
}
```

Device 타입의 addDevice() 메서드는 익셉션을 발생시키므로 이제 아래 코드처럼 익셉션을 이용해서 컴포지트가 아닌 객체에 컴포넌트를 추가하지 못하는 상황을 확인할 수 있습니다.

```java
public void addDeviceTo(Device device, Integer toDeviceId) {
    Device composite = findDevice(toDeviceId);
    try {
        composite.addDevice(device);
    } catch(CanNotAddException ex) {
        ... // 추가할 수 없는 경우의 처리
    }
}
```

익셉션을 발생시키는 방법보다 조금 더 나은 방법이 있다면, 컴포넌트를 추가할 수 있는지의 여부를 판단해 주는 기능을 Device 타입에 정의하는 것입니다.

예를 들어, 다음과 같이 Device 타입에 canContain() 메서드를 추가하는 것입니다.

```java
// Device에 canContain() 추가
public abstract class Device {
    ...
    public boolean canContain(Device device) {
        return false;
    }
}
```

```java
// GroupDevice에서 알맞게 재정의
public class GroupDevice extends Device {
    ...
    @Override
    public void canContain(Device d) {
        return true;
    }
}
```

canContain() 메서드는 파라미터로 전달받는 Device 객체를 추가할 수 있는지 여부를 판단하는 책임을 가지므로, 특정 Device 객체에 다른 Device 객체를 추가할 때에는 canContain() 메서드를 이용해서 추가할 수 있는지의 여부를 확인한 뒤에 추가 기능을 실행할 수 있습니다.

```java
public void addDeviceTo(Device device, Integer toDeviceId) {
    Device composite =  findDevice(toDeviceId);
    if (composite.canContain(device)) {
        composite.addDevice(device);
        return ;
    }
    ... // 추가할 수 없는 경우의 처리
}
```

canContain() 메서드는 객체 등록 여부뿐만 아니라 컴포지트에서 포함할 객체를 제한할 때에도 사용할 수 있습니다.

예를 들어, Aircon 객체만 포함하는 컴포지트 클래스를 만들고 싶다면, 다음과 같이 canContain() 메서드를 구현해 주면 됩니다.

```java
public class OnlyAirconContainingGroup extends GroupDevice {
    @Override
    public boolean canContain(Device device) {
        return (device intancof Aircon);
    }
}
```


## 널(Null) 객체 패턴
장기 고객 할인이라든가 신규 고객 할인과 같이 고객의 상태에 따라 특별 할인을 해준다고 가정해봅시다. 사용 요금 명세서를 생성하는 기능은 아래 코드와 같이 명세서 상세 내역에 특별 할인 기능을 추가할 수 있을 것입니다.

```java
public Bill createBill(Customer customer) {
    Bill bill = new Bill();
    // ... 사용 내역 추가
    bill.addItem(new Item("기본사용요금", price));
    bill.addItem(new Item("할부금", somePrice));

    // 특별 할인 내역 추가
    SpecialDiscount specialDiscount = specialDiscountFactory.create(customer);
    if (specialDiscout != null) { // 특별 할인 대상인 경우만 처리
        specialDiscount.addDetailTo(bill);
    }
}
```

고객에 따라 특별 할인이 없는 경우도 있기 때문에 위 코드에서는 specialDiscount가 null이 아닌 경우에만 특별 할인 내역을 추가하도록 했습니다. null 검사 코드를 사용할 때의 단점은 개발자가 null 검사 코드를 빼 먹기 쉽다는 점입니다. 예를 들어, 아래 코드처럼 한 객체에 대한 null 검사를 여러 코드에서 사용한다고 가정해보겠습니다.

```java
public void someMethod(MyObject obj) {
    if (obj != null) {
        obj.someOperation();
    }
    ...
    callAnyMethod(obj, other);
}

private void callAnyMethod(MyObject obj, Other other) {
    if (other.someOp()) {
        if (obj != null) {
            obj.process();
        }
    } else {
        if( obj != null) {
            obj.processOther();
        }
    }
}
```

이와 같이 여러 코드에서 한 객체에 대한 null 검사를 하게 되면 null 검사 코드를 누락하기 쉬우며, 이는 프로그램 실행 도중에 NullPointException을 발생시킬 가능성을 높여줍니다.

널(Null) 객체 패턴은 null 검사 코드 누락에 따른 문제를 없애 줍니다. 널 객체 패턴은 null을 리턴하지 않고 null을 대신할 객체를 리턴함으로써 null 검사 코드를 업앨 수 있도록 합니다. 널 객체 패턴은 다음과 같이 구현합니다.

- null 대신 사용될 클래스를 구현합니다. 이 클래스는 상위 타입을 상속 받으며, 아무 기능도 수행 하지 않습니다.

- null을 리턴하는 대신, null을 대체할 클래스의 객체를 리턴합니다.

앞서 특별 할인 내역을 명세서에 등록하는 예에서 특별 할인 내역을 처리하기 위해 SpecialDiscount 클래스를 사용했는데, SpecialDiscount 객체가 null일 때 대신 사용할 클래스를 아래 코드처럼 구현합니다.

```java
public class NullSpecialDiscount extends SpecialDiscount {

    @Override
    public void addDetailTo(Bill bill) {
        // 아무것도 하지 않습니다.
    }
}
```

위 코드에서 NullSpecialDiscount 클래스는 SpecialDiscount 클래스를 상속받고 있는데, addDetailTo() 메서드가 아무것도 수행하지 않도록 재정의하고 있습니다.

SpecialDiscount 객체를 생성하는 코드는 이제 null을 리턴하는 대신 NullSpecialDiscount  객체를 리턴하도록 수정합니다.

```java
public class SpecialDiscountFactory {

    public SpecialDiscount create(Customer customer) {
        if (checkNewCustomer(customer)) {
            return new NewCustomerSpecialDiscount();
            ..// 다른 코드 실행

            // 특별 할인 혜택이 없을 때, null 대신 NullSpecialDiscount 객체 리턴
            return new NullSpecialDiscount();        
    }
}
```

이제 SpecialDiscountFactory.create() 메서드를 이용해서 특별 할인 내역을 처리하는 코드는 아래 코드처럼 더 이상 null 검사를 할 필요가 없어집니다.

```java
public Bill createBill(Customer customer) {

    Bill bill = new Bill();
    // .. 특별 할인 내역 추가
    // 특별 할인 대상이 아닐 경우 NullSpecialDiscount 객체 리턴
    SpecialDiscount specialDiscount = specialDiscountFactory.create(customer);
    specialDiscount.addDetailTo(bill); // null 검사 불필요
    ...
    return bill;
}
```

specialDiscountFactory.create() 코드는 해당 고객이 특별 할인 대상이 아닐 경우 NullSpecialDiscount 객체를 리턴합니다. 따라서 위 코드에서 specialDiscount는 null이 되지 않으므로 null 검사를 할 필요가 없어집니다. 또한 specialDiscount가 NullSpecialDiscount 객체인 경우 specialDiscount.addDetailTo() 코드는 아무 동작도 하지 않으므로 어떤 문제도 발생하지 않습니다.

널 객체 패턴을 사용할 때의 장점은 null 검사 코드를 사용할 필요가 없기 때문에 코드가 간결해진다는 점입니다. 코드가 간결해진다는 것은 그 만큼 코드의 가독성을 높여주므로, 향후에 코드 수정을 보다 쉽게 만들어 줍니다.







































